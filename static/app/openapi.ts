/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/0/organizations/{organization_slug}/events/": {
    /**
     * Retrieves discover (also known as events) data for a given organization.
     *
     * **Eventsv2 Deprecation Note**: Users who may be using the `eventsv2` endpoint should update their requests to the `events` endpoint outline in this document.
     * The `eventsv2` endpoint is not a public endpoint and has no guaranteed availability. If you are not making any API calls to `eventsv2`, you can safely ignore this.
     * Changes between `eventsv2` and `events` include:
     * - Field keys in the response now match the keys in the requested `field` param exactly.
     * - The `meta` object in the response now shows types in the nested `field` object.
     *
     * Aside from the url change, there are no changes to the request payload itself.
     *
     * **Note**: This endpoint is intended to get a table of results, and is not for doing a full export of data sent to
     * Sentry.
     *
     * The `field` query parameter determines what fields will be selected in the `data` and `meta` keys of the endpoint response.
     * - The `data` key contains a list of results row by row that match the `query` made
     * - The `meta` key contains information about the response, including the unit or type of the fields requested
     */
    get: operations["Query Discover Events in Table Format"];
  };
  "/api/0/organizations/{organization_slug}/members/{member_id}/": {
    /**
     * Retrieve an organization member's details.
     *
     * Will return a pending invite as long as it's already approved.
     */
    get: operations["Retrieve an Organization Member"];
    /** Remove an organization member. */
    delete: operations["Delete an Organization Member"];
  };
  "/api/0/organizations/{organization_slug}/projects/": {
    /** Return a list of projects bound to a organization. */
    get: operations["List an Organization's Projects"];
  };
  "/api/0/organizations/{organization_slug}/scim/v2/Groups": {
    /**
     * Returns a paginated list of teams bound to a organization with a SCIM Groups GET Request.
     * - Note that the members field will only contain up to 10000 members.
     */
    get: operations["List an Organization's Paginated Teams"];
    /** Create a new team bound to an organization via a SCIM Groups POST Request. Note that teams are always created with an empty member set. The endpoint will also do a normalization of uppercase / spaces to lowercase and dashes. */
    post: operations["Provision a New Team"];
  };
  "/api/0/organizations/{organization_slug}/scim/v2/Groups/{team_id}": {
    /**
     * Query an individual team with a SCIM Group GET Request.
     * - Note that the members field will only contain up to 10000 members.
     */
    get: operations["Query an Individual Team"];
    /** Delete a team with a SCIM Group DELETE Request. */
    delete: operations["Delete an Individual Team"];
    /**
     * Update a team's attributes with a SCIM Group PATCH Request. Valid Operations are:
     * * Renaming a team:
     * ```json
     * {
     *     "op": "replace",
     *     "value": {
     *         "id": 23,
     *         "displayName": "newName"
     *     }
     * }
     * ```
     * * Adding a member to a team:
     * ```json
     * {
     *     "op": "add",
     *     "path": "members",
     *     "value": [
     *         {
     *             "value": 23,
     *             "display": "testexample@example.com"
     *         }
     *     ]
     * }
     * ```
     * * Removing a member from a team:
     * ```json
     * {
     *     "op": "remove",
     *     "path": "members[value eq \"23\"]"
     * }
     * ```
     * *  Replacing an entire member set of a team:
     * ```json
     * {
     *     "op": "replace",
     *     "path": "members",
     *     "value": [
     *         {
     *             "value": 23,
     *             "display": "testexample2@sentry.io"
     *         },
     *         {
     *             "value": 24,
     *             "display": "testexample3@sentry.io"
     *         }
     *     ]
     * }
     * ```
     */
    patch: operations["Update a Team's Attributes"];
  };
  "/api/0/organizations/{organization_slug}/scim/v2/Users": {
    /** Returns a paginated list of members bound to a organization with a SCIM Users GET Request. */
    get: operations["List an Organization's Members"];
    /**
     * Create a new Organization Member via a SCIM Users POST Request.
     * - `userName` should be set to the SAML field used for email, and active should be set to `true`.
     * - Sentry's SCIM API doesn't currently support setting users to inactive,
     * and the member will be deleted if active is set to `false`.
     * - The API also does not support setting secondary emails.
     */
    post: operations["Provision a New Organization Member"];
  };
  "/api/0/organizations/{organization_slug}/scim/v2/Users/{member_id}": {
    /**
     * Query an individual organization member with a SCIM User GET Request.
     * - The `name` object will contain fields `firstName` and `lastName` with the values of `N/A`.
     * Sentry's SCIM API does not currently support these fields but returns them for compatibility purposes.
     */
    get: operations["Query an Individual Organization Member"];
    /** Delete an organization member with a SCIM User DELETE Request. */
    delete: operations["Delete an Organization Member via SCIM"];
    /**
     * Update an organization member's attributes with a SCIM PATCH Request.
     * The only supported attribute is `active`. After setting `active` to false
     * Sentry will permanently delete the Organization Member.
     */
    patch: operations["Update an Organization Member's Attributes"];
  };
  "/api/0/organizations/{organization_slug}/stats_v2/": {
    /**
     * Query event counts for your Organization.
     * Select a field, define a date range, and group or filter by columns.
     */
    get: operations["Retrieve Event Counts for an Organization (v2)"];
  };
  "/api/0/organizations/{organization_slug}/teams/": {
    /** Returns a list of teams bound to a organization. */
    get: operations["List an Organization's Teams"];
    /** Create a new team bound to an organization. Only the name of the team is needed to create it, the slug can be auto generated. */
    post: operations["Create a New Team"];
  };
  "/api/0/teams/{organization_slug}/{team_slug}/": {
    /** Return details on an individual team. */
    get: operations["Retrieve a Team"];
    /** Update various attributes and configurable settings for the given team. */
    put: operations["Update a Team"];
    /**
     * Schedules a team for deletion.
     *
     * Note: Deletion happens asynchronously and therefore is not immediate. However once deletion has begun the state of a project changes and will be hidden from most public views.
     */
    delete: operations["Delete a Team"];
  };
  "/api/0/teams/{organization_slug}/{team_slug}/projects/": {
    /** Return a list of projects bound to a team. */
    get: operations["List a Team's Projects"];
    /** Create a new project bound to a team. */
    post: operations["Create a New Project"];
  };
  "/api/0/teams/{organization_slug}/{team_slug}/stats/": {
    /**
     * Return a set of points representing a normalized timestamp and the number of events seen in the period.
     *
     * Query ranges are limited to Sentryâ€™s configured time-series resolutions.
     */
    get: operations["Retrieve Event Counts for a Team"];
  };
  "/api/0/organizations/": {
    /** Return a list of organizations available to the authenticated session.  This is particularly useful for requests with an user bound context.  For API key based requests this will only return the organization that belongs to the key. */
    get: operations["List Your Organizations"];
  };
  "/api/0/organizations/{organization_slug}/eventids/{event_id}/": {
    /** This resolves an event ID to the project slug and internal issue ID and internal event ID. */
    get: operations["Resolve an Event ID"];
  };
  "/api/0/organizations/{organization_slug}/": {
    /** Return details on an individual organization including various details such as membership access, features, and teams. */
    get: operations["Retrieve an Organization"];
    /** Update various attributes and configurable settings for the given organization. */
    put: operations["Update an Organization"];
  };
  "/api/0/organizations/{organization_slug}/repos/": {
    /** Return a list of version control repositories for a given organization. */
    get: operations["List an Organization's Repositories"];
  };
  "/api/0/organizations/{organization_slug}/repos/{repo_id}/commits/": {
    /** Return a list of commits for a given repository. */
    get: operations["List a Repository's Commits"];
  };
  "/api/0/organizations/{organization_slug}/stats/": {
    /** This endpoint is deprecated in favor of [Organization Stats V2](/api/organizations/retrieve-event-counts-for-an-organization-v2/). */
    get: operations["Retrieve Event Counts for an Organization"];
  };
  "/api/0/organizations/{organization_slug}/sessions/": {
    /**
     * Returns a time series of release health session statistics for projects bound to an organization.
     *
     * The interval and date range are subject to certain restrictions and rounding rules.
     *
     * The date range is rounded to align with the interval, and is rounded to at least one hour. The interval can at most be one day and at least one hour currently. It has to cleanly divide one day, for rounding reasons.
     */
    get: operations["Retrieve Release Health Session Statistics"];
  };
  "/api/0/organizations/{organization_slug}/users/": {
    /** Return a list of users that belong to a given organization. */
    get: operations["List an Organization's Users"];
  };
  "/api/0/organizations/{organization_slug}/shortids/{short_id}/": {
    /** This resolves a short ID to the project slug and internal issue ID. */
    get: operations["Resolve a Short ID"];
  };
  "/api/0/projects/": {
    /** Return a list of projects available to the authenticated session. */
    get: operations["List Your Projects"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/": {
    /** Return details on an individual project. */
    get: operations["Retrieve a Project"];
    /** Update various attributes and configurable settings for the given project.  Only supplied values are updated. */
    put: operations["Update a Project"];
    /**
     * Schedules a project for deletion.
     *
     * Deletion happens asynchronously and therefore is not immediate.
     * However once deletion has begun the state of a project changes and
     * will be hidden from most public views.
     */
    delete: operations["Delete a Project"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/files/dsyms/": {
    /** Retrieve a list of debug information files for a given project. */
    get: operations["List a Project's Debug Information Files"];
    /**
     * Upload a new debug information file for the given release.
     *
     * Unlike other API requests, files must be uploaded using the
     * traditional multipart/form-data content-type.
     *
     * The file uploaded is a zip archive of an Apple .dSYM folder which
     * contains the individual debug images.  Uploading through this endpoint
     * will create different files for the contained images.
     */
    post: operations["Upload a New File"];
    /** Delete a debug information file for a given project. */
    delete: operations["Delete a Specific Project's Debug Information File"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/users/": {
    /** Return a list of users seen within this project. */
    get: operations["List a Project's Users"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/tags/{key}/values/": {
    /**
     * Return a list of values associated with this key.  The `query`
     * parameter can be used to to perform a "contains" match on
     * values.
     *
     * When [paginated](/api/pagination) can return at most 1000 values.
     */
    get: operations["List a Tag's Values"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/stats/": {
    /**
     * Return a set of points representing a normalized timestamp and the
     * number of events seen in the period.
     *
     * Query ranges are limited to Sentry's configured time-series resolutions.
     */
    get: operations["Retrieve Event Counts for a Project"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/user-feedback/": {
    /** Return a list of user feedback items within this project. */
    get: operations["List a Project's User Feedback"];
    /**
     * Submit and associate user feedback with an issue.
     *
     * Feedback must be received by the server no more than 30 minutes after the event was saved.
     *
     * Additionally, within 5 minutes of submitting feedback it may also be overwritten. This is useful in situations where you may need to retry sending a request due to network failures.
     *
     * If feedback is rejected due to a mutability threshold, a 409 status code will be returned.
     *
     * Note: Feedback may be submitted with DSN authentication (see auth documentation).
     */
    post: operations["Submit User Feedback"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/keys/": {
    /** Return a list of client keys bound to a project. */
    get: operations["List a Project's Client Keys"];
    /** Create a new client key bound to a project.  The key's secret and public key are generated by the server. */
    post: operations["Create a New Client Key"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/keys/{key_id}/": {
    /** Update a client key.  This can be used to rename a key. */
    put: operations["Update a Client Key"];
    /** Delete a client key. */
    delete: operations["Delete a Client Key"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/hooks/": {
    /** Return a list of service hooks bound to a project. */
    get: operations["List a Project's Service Hooks"];
    /**
     * Register a new service hook on a project.
     *
     * Events include:
     *
     * - event.alert: An alert is generated for an event (via rules).
     * - event.created: A new event has been processed.
     *
     * This endpoint requires the 'servicehooks' feature to be enabled for your project.
     */
    post: operations["Register a New Service Hook"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/hooks/{hook_id}/": {
    /** Return a service hook bound to a project. */
    get: operations["Retrieve a Service Hook"];
    /** Update a service hook. */
    put: operations["Update a Service Hook"];
    /** Remove a service hook. */
    delete: operations["Remove a Service Hook"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/events/{event_id}/": {
    /** Return details on an individual event. */
    get: operations["Retrieve an Event for a Project"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/events/": {
    /** Return a list of events bound to a project. */
    get: operations["List a Project's Events"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/issues/": {
    /**
     * Return a list of issues (groups) bound to a project.  All parameters are supplied as query string parameters.
     *
     *  A default query of ``is:unresolved`` is applied. To return results with other statuses send an new query value (i.e. ``?query=`` for all results).
     *
     * The ``statsPeriod`` parameter can be used to select the timeline stats which should be present. Possible values are: ``""`` (disable),``"24h"``, ``"14d"``
     */
    get: operations["List a Project's Issues"];
    /**
     * Bulk mutate various attributes on issues.  The list of issues to modify is given through the `id` query parameter.  It is repeated for each issue that should be modified.
     *
     * - For non-status updates, the `id` query parameter is required.
     * - For status updates, the `id` query parameter may be omitted
     * for a batch "update all" query.
     * - An optional `status` query parameter may be used to restrict
     * mutations to only events with the given status.
     *
     * The following attributes can be modified and are supplied as JSON object in the body:
     *
     * If any ids are out of scope this operation will succeed without any data mutation.
     */
    put: operations["Bulk Mutate a List of Issues"];
    /**
     * Permanently remove the given issues. The list of issues to modify is given through the `id` query parameter.  It is repeated for each issue that should be removed.
     *
     * Only queries by 'id' are accepted.
     *
     * If any ids are out of scope this operation will succeed without any data mutation.
     */
    delete: operations["Bulk Remove a List of Issues"];
  };
  "/api/0/issues/{issue_id}/tags/{key}/values/": {
    /**
     * Returns details for given tag key related to an issue.
     *
     * When [paginated](/api/pagination) can return at most 1000 values.
     */
    get: operations["List a Tag's Values Related to an Issue"];
  };
  "/api/0/issues/{issue_id}/tags/{key}/": {
    /** Returns details for given tag key related to an issue. */
    get: operations["Retrieve Tag Details"];
  };
  "/api/0/issues/{issue_id}/hashes/": {
    /** This endpoint lists an issue's hashes, which are the generated checksums used to aggregate individual events. */
    get: operations["List an Issue's Hashes"];
  };
  "/api/0/issues/{issue_id}/events/oldest/": {
    /** Retrieves the details of the oldest event for an issue. */
    get: operations["Retrieve the Oldest Event for an Issue"];
  };
  "/api/0/issues/{issue_id}/events/latest/": {
    /** Retrieves the details of the latest event for an issue. */
    get: operations["Retrieve the Latest Event for an Issue"];
  };
  "/api/0/issues/{issue_id}/events/": {
    /** This endpoint lists an issue's events. */
    get: operations["List an Issue's Events"];
  };
  "/api/0/issues/{issue_id}/": {
    /** Return details on an individual issue. This returns the basic stats for the issue (title, last seen, first seen), some overall numbers (number of comments, user reports) as well as the summarized event data. */
    get: operations["Retrieve an Issue"];
    /** Updates an individual issue's attributes.  Only the attributes submitted are modified. */
    put: operations["Update an Issue"];
    /** Removes an individual issue. */
    delete: operations["Remove an Issue"];
  };
  "/api/0/organizations/{organization_slug}/releases/": {
    /** Return a list of releases for a given organization. */
    get: operations["List an Organization's Releases"];
    /**
     * Create a new release for the given organization.  Releases are used by
     * Sentry to improve its error reporting abilities by correlating
     * first seen events with the release that might have introduced the
     * problem.
     * Releases are also necessary for source maps and other debug features
     * that require manual upload for functioning well.
     */
    post: operations["Create a New Release for an Organization"];
  };
  "/api/0/organizations/{organization_slug}/releases/{version}/": {
    /** Return a release for a given organization. */
    get: operations["Retrieve an Organization's Releases"];
    /** Update a release for a given organization. */
    put: operations["Update an Organization's Release"];
    /** Delete a release for a given organization. */
    delete: operations["Delete an Organization's Release"];
  };
  "/api/0/organizations/{organization_slug}/releases/{version}/files/": {
    /** Return a list of files for a given release. */
    get: operations["List an Organization's Release Files"];
    /** Upload a new organization release file. */
    post: operations["Upload a New Organization Release File"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/files/": {
    /** Return a list of files for a given release. */
    get: operations["List a Project's Release Files"];
    /** Upload a new project release file. */
    post: operations["Upload a New Project Release File"];
  };
  "/api/0/organizations/{organization_slug}/releases/{version}/files/{file_id}/": {
    /** Retrieve a file for a given release. */
    get: operations["Retrieve an Organization Release's File"];
    /** Update an organization release file. */
    put: operations["Update an Organization Release File"];
    /** Delete a file for a given release. */
    delete: operations["Delete an Organization Release's File"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/files/{file_id}/": {
    /** Retrieve a file for a given release. */
    get: operations["Retrieve a Project Release's File"];
    /** Update a project release file. */
    put: operations["Update a Project Release File"];
    /** Delete a file for a given release. */
    delete: operations["Delete a Project Release's File"];
  };
  "/api/0/organizations/{organization_slug}/releases/{version}/commits/": {
    /** List an organization release's commits. */
    get: operations["List an Organization Release's Commits"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/commits/": {
    /** List a project release's commits. */
    get: operations["List a Project Release's Commits"];
  };
  "/api/0/organizations/{organization_slug}/releases/{version}/commitfiles/": {
    /** Retrieve files changed in a release's commits */
    get: operations["Retrieve Files Changed in a Release's Commits"];
  };
  "/api/0/projects/{organization_slug}/{project_slug}/releases/{version}/resolved/": {
    /** List issues to be resolved in a particular release. */
    get: operations["List Issues to be Resolved in a Particular Release"];
  };
  "/api/0/organizations/{organization_slug}/releases/{version}/deploys/": {
    /** Return a list of deploys for a given release. */
    get: operations["List a Release's Deploys"];
    /** Create a deploy. */
    post: operations["Create a New Deploy for an Organization"];
  };
  "/api/0/organizations/{organization_slug}/sentry-app-installations/": {
    /** Return a list of integration platform installations for a given organization. */
    get: operations["List an Organization's Integration Platform Installations"];
  };
  "/api/0/sentry-app-installations/{uuid}/external-issues/": {
    /** Create an external issue from an integration platform integration. */
    post: operations["Create an External Issue"];
  };
  "/api/0/sentry-app-installations/{uuid}/external-issues/{external_issue_id}/": {
    /** Delete an external issue. */
    delete: operations["Delete an External Issue"];
  };
}

export interface components {
  schemas: {
    OrganizationEventsResponseDict: {
      data: { [key: string]: unknown }[];
      meta: {
        fields: { [key: string]: string };
      };
    };
    /**
     * @description Conforming to the SCIM RFC, this represents a Sentry Org Member
     * as a SCIM user object.
     */
    OrganizationMemberSCIM: {
      active?: boolean;
      schemas: string[];
      id: string;
      userName: string;
      name: {
        givenName: string;
        familyName: string;
      };
      emails: {
        primary: boolean;
        value: string;
        type: string;
      }[];
      meta: {
        resourceType: string;
      };
    };
    OrganizationMemberWithRoles: {
      externalUsers?: {
        externalId?: string;
        userId?: string;
        teamId?: string;
        id: string;
        provider: string;
        externalName: string;
        integrationId: string;
      }[];
      id: string;
      email: string;
      name: string;
      user: {
        identities?: {
          id: string;
          name: string;
          organization: {
            slug: string;
            name: string;
          };
          provider: {
            id: string;
            name: string;
          };
          /** Format: date-time */
          dateVerified: string;
          /** Format: date-time */
          dateSynced: string;
        }[];
        avatar?: {
          avatarType: string;
          avatarUuid: string | null;
        };
        id: string;
        name: string;
        username: string;
        email: string;
        avatarUrl: string;
        isActive: boolean;
        hasPasswordAuth: boolean;
        isManaged: boolean;
        /** Format: date-time */
        dateJoined: string;
        /** Format: date-time */
        lastLogin: string;
        has2fa: boolean;
        /** Format: date-time */
        lastActive: string;
        isSuperuser: boolean;
        isStaff: boolean;
        experiments: { [key: string]: unknown };
        emails: {
          id: string;
          email: string;
          is_verified: boolean;
        }[];
      };
      role: string;
      roleName: string;
      orgRole: string;
      pending: boolean;
      expired: string;
      flags: {
        "sso:linked": boolean;
        "sso:invalid": boolean;
        "member-limit:restricted": boolean;
      };
      /** Format: date-time */
      dateCreated: string;
      inviteStatus: string;
      inviterName: string | null;
      teams: string[];
      teamRoles: {
        teamSlug: string;
        role: string;
      }[];
      invite_link: string | null;
      isOnlyOwner: boolean;
      roles: {
        id: string;
        name: string;
        desc: string;
        scopes: string[];
        is_global: boolean;
        allowed: boolean;
      }[];
      orgRoleList: {
        id: string;
        name: string;
        desc: string;
        scopes: string[];
        is_global: boolean;
        allowed: boolean;
      }[];
      teamRoleList: {
        id: string;
        name: string;
        desc: string;
        scopes: string[];
        is_global: boolean;
        allowed: boolean;
      }[];
    };
    OrganizationProjectResponseDict: {
      latestDeploys?: { [key: string]: { [key: string]: string } } | null;
      stats?: unknown;
      transactionStats?: unknown;
      sessionStats?: unknown;
      id: string;
      name: string;
      slug: string;
      isBookmarked: boolean;
      isMember: boolean;
      hasAccess: boolean;
      /** Format: date-time */
      dateCreated: string;
      features: string[];
      firstTransactionEvent: boolean;
      hasSessions: boolean;
      hasProfiles: boolean;
      platform: string | null;
      /** Format: date-time */
      firstEvent: string | null;
      team: {
        id: string;
        name: string;
        slug: string;
      } | null;
      teams: {
        id: string;
        name: string;
        slug: string;
      }[];
      eventProcessing: {
        symbolicationDegraded: boolean;
      };
      platforms: string[];
      hasUserReports: boolean;
      environments: string[];
      latestRelease: {
        version: string;
      } | null;
    }[];
    OutcomesResponse: {
      start: string;
      end: string;
      intervals: string[];
      groups: {
        by: { [key: string]: unknown };
        totals: { [key: string]: unknown };
        series: { [key: string]: unknown };
      }[];
    };
    SCIMListResponseEnvelopeSCIMMemberIndexResponse: {
      schemas: string[];
      totalResults: number;
      startIndex: number;
      itemsPerPage: number;
      Resources: {
        active?: boolean;
        schemas: string[];
        id: string;
        userName: string;
        name: {
          givenName: string;
          familyName: string;
        };
        emails: {
          primary: boolean;
          value: string;
          type: string;
        }[];
        meta: {
          resourceType: string;
        };
      }[];
    };
    SCIMListResponseEnvelopeSCIMTeamIndexResponse: {
      schemas: string[];
      totalResults: number;
      startIndex: number;
      itemsPerPage: number;
      Resources: {
        schemas: string[];
        id: string;
        displayName: string;
        meta: {
          resourceType: string;
        };
        members?: {
          value: string;
          display: string;
        }[];
      }[];
    };
    SCIMMemberProvision: {
      /** Format: email */
      userName: string;
    };
    SCIMPatchOperation: {
      /** @enum {string} */
      op: "replace";
      value: unknown;
      path?: string;
    };
    SCIMPatchRequest: {
      schemas?: string[];
      Operations: {
        /** @enum {string} */
        op: "replace";
        value: unknown;
        path?: string;
      }[];
    };
    SCIMTeamPatchOperation: {
      /** @enum {string} */
      op: "replace" | "remove" | "add";
      value: unknown[];
    };
    SCIMTeamPatchRequest: {
      schemas: string[];
      Operations: {
        /** @enum {string} */
        op: "replace" | "remove" | "add";
        value: unknown[];
      }[];
    };
    SCIMTeamRequestBody: {
      schemas: unknown[];
      displayName: string;
      members: unknown[];
    };
    TeamSCIM: {
      schemas: string[];
      id: string;
      displayName: string;
      meta: {
        resourceType: string;
      };
      members?: {
        value: string;
        display: string;
      }[];
    };
  };
}

export interface operations {
  /**
   * Retrieves discover (also known as events) data for a given organization.
   *
   * **Eventsv2 Deprecation Note**: Users who may be using the `eventsv2` endpoint should update their requests to the `events` endpoint outline in this document.
   * The `eventsv2` endpoint is not a public endpoint and has no guaranteed availability. If you are not making any API calls to `eventsv2`, you can safely ignore this.
   * Changes between `eventsv2` and `events` include:
   * - Field keys in the response now match the keys in the requested `field` param exactly.
   * - The `meta` object in the response now shows types in the nested `field` object.
   *
   * Aside from the url change, there are no changes to the request payload itself.
   *
   * **Note**: This endpoint is intended to get a table of results, and is not for doing a full export of data sent to
   * Sentry.
   *
   * The `field` query parameter determines what fields will be selected in the `data` and `meta` keys of the endpoint response.
   * - The `data` key contains a list of results row by row that match the `query` made
   * - The `meta` key contains information about the response, including the unit or type of the fields requested
   */
  "Query Discover Events in Table Format": {
    parameters: {
      query: {
        /** The end of the period of time for the query, expected in ISO-8601 format. For example `2001-12-14T12:34:56.7890` */
        end?: string;
        /** The name of environments to filter by. */
        environment?: string[];
        /** The ids of projects to filter by. `-1` means all available projects. If thisÂ parameter is omitted, the request will default to using 'My Projects' */
        project?: number[];
        /** The start of the period of time for the query, expected in ISO-8601 format. For example `2001-12-14T12:34:56.7890` */
        start?: string;
        /**
         * The period of time for the query, will override the start & end parameters, a number followed by one of:
         * - `d` for days
         * - `h` for hours
         * - `m` for minutes
         * - `s` for seconds
         * - `w` for weeks
         *
         * For example `24h`, to mean query data starting from 24 hours ago to now.
         */
        statsPeriod?: string;
        /**
         * The fields, functions, or equations to request for the query. At most 20 fields can be selected per request. Each field can be one of the following types:
         * - A built-in key field. See possible fields in the [properties table](/product/sentry-basics/search/searchable-properties/#properties-table), under any field that is an event property
         *     - example: `field=transaction`
         * - A tag. Tags should use the `tag[]` formatting to avoid ambiguity with any fields
         *     - example: `field=tag[isEnterprise]`
         * - A function which will be in the format of `function_name(parameters,...)`. See possible functions in the [query builder documentation](/product/discover-queries/query-builder/#stacking-functions)
         *     - when a function is included, Discover will group by any tags or fields
         *     - example: `field=count_if(transaction.duration,greater,300)`
         * - An equation when prefixed with `equation|`. Read more about [equations here](https://docs.sentry.io/product/discover-queries/query-builder/query-equations/)
         *     - example: `field=equation|count_if(transaction.duration,greater,300) / count() * 100`
         */
        field: string[];
        /** Limit the number of rows to return in the result. Default and maximum allowed is 100. */
        per_page?: number;
        /**
         * The search filter for your query, read more about query syntax [here](https://docs.sentry.io/product/sentry-basics/search/)
         *
         * example: `query=(transaction:foo AND release:abc) OR (transaction:[bar,baz] AND release:def)`
         */
        query?: string;
        /** What to order the results of the query by. Must be something in the `field` list, excluding equations. */
        sort?: string;
      };
      path: {
        /** The slug of the organization the resource belongs to. */
        organization_slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            data: { [key: string]: unknown }[];
            meta: {
              fields: { [key: string]: string };
            };
          };
        };
      };
      /** Invalid Query */
      400: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /**
   * Retrieve an organization member's details.
   *
   * Will return a pending invite as long as it's already approved.
   */
  "Retrieve an Organization Member": {
    parameters: {
      path: {
        /** The slug of the organization the resource belongs to. */
        organization_slug: string;
        /** The member ID. */
        member_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            externalUsers?: {
              externalId?: string;
              userId?: string;
              teamId?: string;
              id: string;
              provider: string;
              externalName: string;
              integrationId: string;
            }[];
            id: string;
            email: string;
            name: string;
            user: {
              identities?: {
                id: string;
                name: string;
                organization: {
                  slug: string;
                  name: string;
                };
                provider: {
                  id: string;
                  name: string;
                };
                /** Format: date-time */
                dateVerified: string;
                /** Format: date-time */
                dateSynced: string;
              }[];
              avatar?: {
                avatarType: string;
                avatarUuid: string | null;
              };
              id: string;
              name: string;
              username: string;
              email: string;
              avatarUrl: string;
              isActive: boolean;
              hasPasswordAuth: boolean;
              isManaged: boolean;
              /** Format: date-time */
              dateJoined: string;
              /** Format: date-time */
              lastLogin: string;
              has2fa: boolean;
              /** Format: date-time */
              lastActive: string;
              isSuperuser: boolean;
              isStaff: boolean;
              experiments: { [key: string]: unknown };
              emails: {
                id: string;
                email: string;
                is_verified: boolean;
              }[];
            };
            role: string;
            roleName: string;
            orgRole: string;
            pending: boolean;
            expired: string;
            flags: {
              "sso:linked": boolean;
              "sso:invalid": boolean;
              "member-limit:restricted": boolean;
            };
            /** Format: date-time */
            dateCreated: string;
            inviteStatus: string;
            inviterName: string | null;
            teams: string[];
            teamRoles: {
              teamSlug: string;
              role: string;
            }[];
            invite_link: string | null;
            isOnlyOwner: boolean;
            roles: {
              id: string;
              name: string;
              desc: string;
              scopes: string[];
              is_global: boolean;
              allowed: boolean;
            }[];
            orgRoleList: {
              id: string;
              name: string;
              desc: string;
              scopes: string[];
              is_global: boolean;
              allowed: boolean;
            }[];
            teamRoleList: {
              id: string;
              name: string;
              desc: string;
              scopes: string[];
              is_global: boolean;
              allowed: boolean;
            }[];
          };
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Remove an organization member. */
  "Delete an Organization Member": {
    parameters: {
      path: {
        /** The slug of the organization the resource belongs to. */
        organization_slug: string;
        /** The member ID. */
        member_id: string;
      };
    };
    responses: {
      /** No Content */
      204: never;
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Return a list of projects bound to a organization. */
  "List an Organization's Projects": {
    parameters: {
      path: {
        /** The slug of the organization the resource belongs to. */
        organization_slug: string;
      };
      query: {
        /** A pointer to the last object fetched and its sort order; used to retrieve the next or previous results. */
        cursor?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            latestDeploys?: { [key: string]: { [key: string]: string } } | null;
            stats?: unknown;
            transactionStats?: unknown;
            sessionStats?: unknown;
            id: string;
            name: string;
            slug: string;
            isBookmarked: boolean;
            isMember: boolean;
            hasAccess: boolean;
            /** Format: date-time */
            dateCreated: string;
            features: string[];
            firstTransactionEvent: boolean;
            hasSessions: boolean;
            hasProfiles: boolean;
            platform: string | null;
            /** Format: date-time */
            firstEvent: string | null;
            team: {
              id: string;
              name: string;
              slug: string;
            } | null;
            teams: {
              id: string;
              name: string;
              slug: string;
            }[];
            eventProcessing: {
              symbolicationDegraded: boolean;
            };
            platforms: string[];
            hasUserReports: boolean;
            environments: string[];
            latestRelease: {
              version: string;
            } | null;
          }[];
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /**
   * Returns a paginated list of teams bound to a organization with a SCIM Groups GET Request.
   * - Note that the members field will only contain up to 10000 members.
   */
  "List an Organization's Paginated Teams": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
      };
      query: {
        /** SCIM 1-offset based index for pagination. */
        startIndex?: number;
        /** A SCIM filter expression. The only operator currently supported is `eq`. */
        filter?: string;
        /** The maximum number of results the query should return, maximum of 100. */
        count?: number;
        /** Fields that should be left off of return values. Right now the only supported field for this query is `members`. */
        excludedAttributes?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            schemas?: string[];
            totalResults: number;
            itemsPerPage: number;
            startIndex: number;
            Resources: {
              schemas: string[];
              id: string;
              displayName: string;
              members: {
                value: string;
                display: string;
              }[];
              meta: {
                resourceType?: string;
              };
            }[];
          };
        };
      };
      /** Permission Denied */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Create a new team bound to an organization via a SCIM Groups POST Request. Note that teams are always created with an empty member set. The endpoint will also do a normalization of uppercase / spaces to lowercase and dashes. */
  "Provision a New Team": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            schemas: string[];
            id: string;
            displayName: string;
            members: {
              value: string;
              display: string;
            }[];
            meta: {
              resourceType?: string;
            };
          };
        };
      };
      /** Bad input */
      400: unknown;
      /** Forbidden */
      403: unknown;
      /** Team slug already exists */
      409: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          schemas: string[];
          displayName: string;
          members?: {
            value: string;
            display: string;
          }[];
        };
      };
    };
  };
  /**
   * Query an individual team with a SCIM Group GET Request.
   * - Note that the members field will only contain up to 10000 members.
   */
  "Query an Individual Team": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The id of the team you'd like to query. */
        team_id: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            schemas: string[];
            id: string;
            displayName: string;
            members: {
              value: string;
              display: string;
            }[];
            meta: {
              resourceType?: string;
            };
          };
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
    };
  };
  /** Delete a team with a SCIM Group DELETE Request. */
  "Delete an Individual Team": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The id of the team you'd like to delete. */
        team_id: number;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Not Found */
      404: unknown;
    };
  };
  /**
   * Update a team's attributes with a SCIM Group PATCH Request. Valid Operations are:
   * * Renaming a team:
   * ```json
   * {
   *     "op": "replace",
   *     "value": {
   *         "id": 23,
   *         "displayName": "newName"
   *     }
   * }
   * ```
   * * Adding a member to a team:
   * ```json
   * {
   *     "op": "add",
   *     "path": "members",
   *     "value": [
   *         {
   *             "value": 23,
   *             "display": "testexample@example.com"
   *         }
   *     ]
   * }
   * ```
   * * Removing a member from a team:
   * ```json
   * {
   *     "op": "remove",
   *     "path": "members[value eq \"23\"]"
   * }
   * ```
   * *  Replacing an entire member set of a team:
   * ```json
   * {
   *     "op": "replace",
   *     "path": "members",
   *     "value": [
   *         {
   *             "value": 23,
   *             "display": "testexample2@sentry.io"
   *         },
   *         {
   *             "value": 24,
   *             "display": "testexample3@sentry.io"
   *         }
   *     ]
   * }
   * ```
   */
  "Update a Team's Attributes": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The id of the team you'd like to query. */
        team_id: number;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found. */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          schemas: string[];
          Operations: { [key: string]: unknown }[];
        };
      };
    };
  };
  /** Returns a paginated list of members bound to a organization with a SCIM Users GET Request. */
  "List an Organization's Members": {
    parameters: {
      path: {
        /** The slug of the organization the resource belongs to. */
        organization_slug: string;
      };
      query: {
        /** SCIM 1-offset based index for pagination. */
        startIndex?: number;
        /** The maximum number of results the query should return, maximum of 100. */
        count?: number;
        /** A SCIM filter expression. The only operator currently supported is `eq`. */
        filter?: string;
        /** Fields that should be left off of return values. Right now the only supported field for this query is members. */
        excludedAttributes?: string[];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            schemas: string[];
            totalResults: number;
            startIndex: number;
            itemsPerPage: number;
            Resources: {
              active?: boolean;
              schemas: string[];
              id: string;
              userName: string;
              name: {
                givenName: string;
                familyName: string;
              };
              emails: {
                primary: boolean;
                value: string;
                type: string;
              }[];
              meta: {
                resourceType: string;
              };
            }[];
          };
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /**
   * Create a new Organization Member via a SCIM Users POST Request.
   * - `userName` should be set to the SAML field used for email, and active should be set to `true`.
   * - Sentry's SCIM API doesn't currently support setting users to inactive,
   * and the member will be deleted if active is set to `false`.
   * - The API also does not support setting secondary emails.
   */
  "Provision a New Organization Member": {
    parameters: {
      path: {
        /** The slug of the organization the resource belongs to. */
        organization_slug: string;
      };
    };
    responses: {
      201: {
        content: {
          "application/json": {
            active?: boolean;
            schemas: string[];
            id: string;
            userName: string;
            name: {
              givenName: string;
              familyName: string;
            };
            emails: {
              primary: boolean;
              value: string;
              type: string;
            }[];
            meta: {
              resourceType: string;
            };
          };
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: email */
          userName: string;
        };
      };
    };
  };
  /**
   * Query an individual organization member with a SCIM User GET Request.
   * - The `name` object will contain fields `firstName` and `lastName` with the values of `N/A`.
   * Sentry's SCIM API does not currently support these fields but returns them for compatibility purposes.
   */
  "Query an Individual Organization Member": {
    parameters: {
      path: {
        /** The slug of the organization the resource belongs to. */
        organization_slug: string;
        /** The id of the member you'd like to query. */
        member_id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            active?: boolean;
            schemas: string[];
            id: string;
            userName: string;
            name: {
              givenName: string;
              familyName: string;
            };
            emails: {
              primary: boolean;
              value: string;
              type: string;
            }[];
            meta: {
              resourceType: string;
            };
          };
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Delete an organization member with a SCIM User DELETE Request. */
  "Delete an Organization Member via SCIM": {
    parameters: {
      path: {
        /** The slug of the organization the resource belongs to. */
        organization_slug: string;
        /** The id of the member you'd like to query. */
        member_id: number;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /**
   * Update an organization member's attributes with a SCIM PATCH Request.
   * The only supported attribute is `active`. After setting `active` to false
   * Sentry will permanently delete the Organization Member.
   */
  "Update an Organization Member's Attributes": {
    parameters: {
      path: {
        /** The slug of the organization the resource belongs to. */
        organization_slug: string;
        /** The id of the member you'd like to query. */
        member_id: number;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          schemas?: string[];
          Operations: {
            /** @enum {string} */
            op: "replace";
            value: unknown;
            path?: string;
          }[];
        };
      };
    };
  };
  /**
   * Query event counts for your Organization.
   * Select a field, define a date range, and group or filter by columns.
   */
  "Retrieve Event Counts for an Organization (v2)": {
    parameters: {
      path: {
        /** The slug of the organization the resource belongs to. */
        organization_slug: string;
      };
      query: {
        /** This defines the range of the time series, relative to now. The range is given in a `<number><unit>` format. For example `1d` for a one day range. Possible units are `m` for minutes, `h` for hours, `d` for days and `w` for weeks.You must either provide a `statsPeriod`, or a `start` and `end`. */
        statsPeriod?: string;
        /** This is the resolution of the time series, given in the same format as `statsPeriod`. The default resolution is `1h` and the minimum resolution is currently restricted to `1h` as well. Intervals larger than `1d` are not supported, and the interval has to cleanly divide one day. */
        interval?: string;
        /** This defines the start of the time series range as an explicit datetime, either in UTC ISO8601 or epoch seconds.Use along with `end` instead of `statsPeriod`. */
        start?: string;
        /** This defines the inclusive end of the time series range as an explicit datetime, either in UTC ISO8601 or epoch seconds.Use along with `start` instead of `statsPeriod`. */
        end?: string;
        /** can pass multiple groupBy parameters to group by multiple, e.g.Â `groupBy=project&groupBy=outcome`Â to group by multiple dimensions. Note that grouping by project can cause missing rows if the number of projects / interval is large. If you have a large number of projects, we recommend filtering and querying by them individually.Also note that grouping by projects does not currently support timeseries interval responses and will instead be a sum of the projectover the entire period specified. */
        groupBy: ("outcome" | "category" | "reason" | "project")[];
        /**
         * the `sum(quantity)` field is bytes for attachments, and all others the 'event' count for those types of events.
         *
         * `sum(times_seen)` sums the number of times an event has been seen. For 'normal' event types, this will be equal toÂ `sum(quantity)`Â for now. For sessions, quantity will sum the total number of events seen in a session, while `times_seen` will be the unique number of sessions. and for attachments, `times_seen` will be the total number of attachments, while quantity will be the total sum of attachment bytes.
         */
        field: "sum(quantity)" | "sum(times_seen)";
        /**
         * The ID of the projects to filter by.
         *
         * Use `-1` to include all accessible projects.
         */
        project?: unknown[];
        /**
         * If filtering by attachments, you cannot filter by any other category due to quantity values becoming nonsensical (combining bytes and event counts).
         *
         * If filtering byÂ `error`, it will automatically addÂ `default`Â andÂ `security`Â as we currently roll those two categories intoÂ `error`Â for displaying.
         */
        category?: "error" | "transaction" | "attachment";
        /** See https://docs.sentry.io/product/stats/ for more information on outcome statuses. */
        outcome?:
          | "accepted"
          | "filtered"
          | "rate_limited"
          | "invalid"
          | "abuse"
          | "client_discard";
        /** The reason field will contain why an event was filtered/dropped. */
        reason?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            start: string;
            end: string;
            intervals: string[];
            groups: {
              by: { [key: string]: unknown };
              totals: { [key: string]: unknown };
              series: { [key: string]: unknown };
            }[];
          };
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Returns a list of teams bound to a organization. */
  "List an Organization's Teams": {
    parameters: {
      path: {
        /** The slug of the organization for which the teams should be listed. */
        organization_slug: string;
      };
      query: {
        /** A pointer to the last object fetched and its sort order; used to retrieve the next or previous results. */
        cursor?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            /** Format: date-time */
            dateCreated: string;
            hasAccess: boolean;
            id: string;
            isMember: boolean;
            isPending: boolean;
            /** Format: int64 */
            memberCount: number;
            name: string;
            projects: {
              avatar: {
                avatarType?: string;
                avatarUuid?: string | null;
              };
              color: string;
              /** Format: date-time */
              dateCreated: string;
              features: string[];
              firstEvent: string | null;
              hasAccess: boolean;
              id: string;
              isBookmarked: boolean;
              isInternal: boolean;
              isMember: boolean;
              isPublic: boolean;
              name: string;
              platform: string | null;
              slug: string;
              /** @enum {string} */
              status:
                | "active"
                | "disabled"
                | "pending_deletion"
                | "deletion_in_progress";
            }[];
            slug: string;
          }[];
        };
      };
      /** Permission Denied */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Create a new team bound to an organization. Only the name of the team is needed to create it, the slug can be auto generated. */
  "Create a New Team": {
    parameters: {
      path: {
        /** The slug of the organization the team should be created for. */
        organization_slug: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            /** Format: date-time */
            dateCreated: string;
            hasAccess: boolean;
            id: string;
            isMember: boolean;
            isPending: boolean;
            /** Format: int64 */
            memberCount: number;
            name: string;
            slug: string;
          };
        };
      };
      /** Bad input */
      400: unknown;
      /** Forbidden */
      403: unknown;
      /** Team slug already exists */
      409: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The name of the team. */
          name: string;
          /** @description The optional slug for this team. If not provided it will be auto generated from the name. */
          slug?: string;
        };
      };
    };
  };
  /** Return details on an individual team. */
  "Retrieve a Team": {
    parameters: {
      path: {
        /** The slug of the organization the team belongs to. */
        organization_slug: string;
        /** The slug of the team to get. */
        team_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            /** Format: date-time */
            dateCreated: string;
            hasAccess: boolean;
            id: string;
            isMember: boolean;
            isPending: boolean;
            /** Format: int64 */
            memberCount: number;
            organization: {
              avatar: {
                avatarType?: string;
                avatarUuid?: string | null;
              };
              /** Format: date-time */
              dateCreated: string;
              id: string;
              isEarlyAdopter: boolean;
              name: string;
              require2FA: boolean;
              slug: string;
              status: {
                id: string;
                name: string;
              };
            };
            name: string;
            slug: string;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** Team not found */
      404: unknown;
    };
  };
  /** Update various attributes and configurable settings for the given team. */
  "Update a Team": {
    parameters: {
      path: {
        /** The slug of the organization the team belongs to. */
        organization_slug: string;
        /** The slug of the team to get. */
        team_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            /** Format: date-time */
            dateCreated: string;
            hasAccess: boolean;
            id: string;
            isMember: boolean;
            isPending: boolean;
            /** Format: int64 */
            memberCount: number;
            name: string;
            slug: string;
          };
        };
      };
      /** Bad Input */
      400: unknown;
      /** Forbidden */
      403: unknown;
      /** Team not found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The new name for the team. */
          name: string;
          /** @description A new slug for the team. It has to be unique and available. */
          slug?: string;
        };
      };
    };
  };
  /**
   * Schedules a team for deletion.
   *
   * Note: Deletion happens asynchronously and therefore is not immediate. However once deletion has begun the state of a project changes and will be hidden from most public views.
   */
  "Delete a Team": {
    parameters: {
      path: {
        /** The slug of the organization the team belongs to. */
        organization_slug: string;
        /** The slug of the team to get. */
        team_slug: string;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Forbidden */
      403: unknown;
      /** Team not found */
      404: unknown;
    };
  };
  /** Return a list of projects bound to a team. */
  "List a Team's Projects": {
    parameters: {
      path: {
        /** The slug of the organization the team belongs to. */
        organization_slug: string;
        /** The slug of the team to get. */
        team_slug: string;
      };
      query: {
        /** A pointer to the last object fetched and its sort order; used to retrieve the next or previous results. */
        cursor?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** Format: date-time */
            dateCreated: string;
            features: string[];
            firstEvent: string | null;
            hasAccess: boolean;
            id: string;
            isBookmarked: boolean;
            isMember: boolean;
            name: string;
            platform: string | null;
            slug: string;
            team: {
              id: string;
              name: string;
              slug: string;
            };
            teams: {
              id: string;
              name: string;
              slug: string;
            }[];
            latestDeploys: string | null;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
      /** Team not found */
      404: unknown;
    };
  };
  /** Create a new project bound to a team. */
  "Create a New Project": {
    parameters: {
      path: {
        /** The slug of the organization the team belongs to. */
        organization_slug: string;
        /** The slug of the team to create a new project for. */
        team_slug: string;
      };
    };
    responses: {
      /** Created */
      201: {
        content: {
          "application/json": {
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            color: string;
            /** Format: date-time */
            dateCreated: string;
            features: string[];
            firstEvent: string | null;
            hasAccess: boolean;
            id: string;
            isBookmarked: boolean;
            isInternal: boolean;
            isMember: boolean;
            isPublic: boolean;
            name: string;
            platform: string | null;
            slug: string;
            /** @enum {string} */
            status:
              | "active"
              | "disabled"
              | "pending_deletion"
              | "deletion_in_progress";
          };
        };
      };
      /** Bad input */
      400: unknown;
      /** Forbidden */
      403: unknown;
      /** Team not found */
      404: unknown;
      /** A project with the given slug already exists */
      409: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The name for the new project. */
          name: string;
          /** @description Optional slug for the new project. If not provided a slug is generated from the name. */
          slug?: string;
        };
      };
    };
  };
  /**
   * Return a set of points representing a normalized timestamp and the number of events seen in the period.
   *
   * Query ranges are limited to Sentryâ€™s configured time-series resolutions.
   */
  "Retrieve Event Counts for a Team": {
    parameters: {
      path: {
        /** The slug of the organization the team belongs to. */
        organization_slug: string;
        /** The slug of the team to get. */
        team_slug: string;
      };
      query: {
        /** The name of the stat to query `("received", "rejected")`. */
        stat?: "received" | "rejected";
        /** A timestamp to set the start of the query in seconds since UNIX epoch. */
        since?: string;
        /** A timestamp to set the end of the query in seconds since UNIX epoch. */
        until?: string;
        /** An explicit resolution to search for (one of `10s`, `1h`, and `1d`). */
        resolution?: "10s" | "1h" | "1d";
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": number[][];
        };
      };
      /** Forbidden */
      403: unknown;
      /** Team not found */
      404: unknown;
    };
  };
  /** Return a list of organizations available to the authenticated session.  This is particularly useful for requests with an user bound context.  For API key based requests this will only return the organization that belongs to the key. */
  "List Your Organizations": {
    parameters: {
      query: {
        /** Restrict results to organizations in which you are an organization owner. */
        owner?: boolean;
        /** A pointer to the last object fetched and its sort order; used to retrieve the next or previous results. */
        cursor?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            /** Format: date-time */
            dateCreated: string;
            id: string;
            isEarlyAdopter: boolean;
            name: string;
            require2FA: boolean;
            slug: string;
            status: {
              id: string;
              name: string;
            };
          }[];
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
    };
  };
  /** This resolves an event ID to the project slug and internal issue ID and internal event ID. */
  "Resolve an Event ID": {
    parameters: {
      path: {
        /** The slug of the organization the event ID should be looked up in. */
        organization_slug: string;
        /** The event ID to look up. */
        event_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            event: {
              _meta: {
                context?: string | null;
                contexts?: { [key: string]: unknown } | null;
                entries?: { [key: string]: unknown };
                message?: string | null;
                packages?: string | null;
                sdk?: string | null;
                tags?: { [key: string]: unknown };
                user?: string | null;
              };
              context: {
                length?: number;
                results?: number[];
                session?: {
                  foo?: string;
                };
                unauthorized?: boolean;
                url?: string;
              };
              contexts: { [key: string]: unknown };
              dateCreated: string;
              dateReceived: string;
              dist: string | null;
              entries: (Partial<{
                type: string;
                data: {
                  values: {
                    category: string;
                    level: string;
                    event_id: string | null;
                    /** Format: date-time */
                    timestamp: string;
                    data: { [key: string]: unknown } | null;
                    message: string | null;
                    type: string;
                  }[];
                };
              }> &
                Partial<{
                  type: string;
                  data: {
                    fragment: string | null;
                    cookies: string[][] | null;
                    inferredContentType: string | null;
                    env: {
                      ENV?: string;
                    } | null;
                    headers: string[][];
                    url: string;
                    query: string[][];
                    data: { [key: string]: unknown } | null;
                    method: string | null;
                  };
                }> &
                Partial<{
                  type: string;
                  data: {
                    formatted: string;
                  };
                }> &
                Partial<{
                  type: string;
                  data: {
                    excOmitted: number[] | null;
                    hasSystemFrames: boolean;
                    values: {
                      stacktrace: {
                        frames: {
                          function: string;
                          errors: string | null;
                          colNo: number | null;
                          vars: { [key: string]: unknown } | null;
                          package: string | null;
                          absPath: string | null;
                          inApp: boolean;
                          lineNo: number;
                          module: string;
                          filename: string;
                          platform: string | null;
                          instructionAddr: string | null;
                          context: (number | string)[][];
                          symbolAddr: string | null;
                          trust: string | null;
                          symbol: string | null;
                        }[];
                        framesOmitted: string | null;
                        registers: string | null;
                        hasSystemFrames: boolean;
                      } | null;
                      module: string | null;
                      rawStacktrace: { [key: string]: unknown } | null;
                      mechanism: {
                        type?: string;
                        handled?: boolean;
                      } | null;
                      threadId: string | null;
                      value: string;
                      type: string;
                    }[];
                  };
                }>)[];
              errors: {
                message?: string;
                type?: string;
                data?: { [key: string]: unknown };
              }[];
              eventID: string;
              fingerprints: string[];
              groupID: string;
              id: string;
              message: string;
              metadata: {
                title?: string;
              };
              packages: {
                "my.package"?: string;
              };
              platform: string;
              sdk: { [key: string]: unknown } | null;
              size: number;
              tags: {
                _meta?: string | null;
                key?: string;
                value?: string;
              }[];
              type: string;
              user: {
                username: string | null;
                name: string | null;
                ip_address: string | null;
                email: string | null;
                data: {
                  isStaff?: boolean;
                } | null;
                id: string;
              } | null;
              title: string;
            };
            eventId: string;
            groupId: string;
            organizationSlug: string;
            projectSlug: string;
          };
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Return details on an individual organization including various details such as membership access, features, and teams. */
  "Retrieve an Organization": {
    parameters: {
      path: {
        /** The slug of the organization to look up. */
        organization_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            access: string[];
            allowSharedIssues: boolean;
            availableRoles: {
              id?: string;
              name?: string;
            }[];
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            dataScrubber: boolean;
            dataScrubberDefaults: boolean;
            /** Format: date-time */
            dateCreated: string;
            defaultRole: string;
            enhancedPrivacy: boolean;
            experiments: { [key: string]: unknown };
            features: string[];
            id: string;
            isDefault: boolean;
            isEarlyAdopter: boolean;
            name: string;
            onboardingTasks: { [key: string]: unknown }[];
            openMembership: boolean;
            /** Format: int64 */
            pendingAccessRequests: number;
            projects: {
              dateCreated: string;
              firstEvent: string | null;
              hasAccess: boolean;
              id: string;
              isBookmarked: boolean;
              isMember: boolean;
              latestDeploys: string | null;
              name: string;
              platform: string | null;
              platforms: string[];
              slug: string;
              team:
                | (
                    | {
                        id: string;
                        name: string;
                        slug: string;
                      }
                    | (unknown | null)
                  )
                | null;
              teams: {
                id: string;
                name: string;
                slug: string;
              }[];
            }[];
            quota: { [key: string]: unknown };
            require2FA: boolean;
            safeFields: string[];
            scrapeJavaScript: boolean;
            scrubIPAddresses: boolean;
            sensitiveFields: string[];
            slug: string;
            status: {
              id?: string;
              name?: string;
            };
            /** Format: int64 */
            storeCrashReports: number;
            teams: {
              avatar: {
                avatarType?: string;
                avatarUuid?: string | null;
              };
              /** Format: date-time */
              dateCreated: string;
              hasAccess: boolean;
              id: string;
              isMember: boolean;
              isPending: boolean;
              /** Format: int64 */
              memberCount: number;
              name: string;
              slug: string;
            }[];
            trustedRelays: string[];
          };
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
  };
  /** Update various attributes and configurable settings for the given organization. */
  "Update an Organization": {
    parameters: {
      path: {
        /** The slug of the organization to update. */
        organization_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            access: string[];
            allowSharedIssues: boolean;
            availableRoles: {
              id?: string;
              name?: string;
            }[];
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            dataScrubber: boolean;
            dataScrubberDefaults: boolean;
            /** Format: date-time */
            dateCreated: string;
            defaultRole: string;
            enhancedPrivacy: boolean;
            experiments: { [key: string]: unknown };
            features: string[];
            id: string;
            isDefault: boolean;
            isEarlyAdopter: boolean;
            name: string;
            onboardingTasks: { [key: string]: unknown }[];
            openMembership: boolean;
            /** Format: int64 */
            pendingAccessRequests: number;
            projects: {
              dateCreated: string;
              firstEvent: string | null;
              hasAccess: boolean;
              id: string;
              isBookmarked: boolean;
              isMember: boolean;
              latestDeploys: string | null;
              name: string;
              platform: string | null;
              platforms: string[];
              slug: string;
              team:
                | (
                    | {
                        id: string;
                        name: string;
                        slug: string;
                      }
                    | (unknown | null)
                  )
                | null;
              teams: {
                id: string;
                name: string;
                slug: string;
              }[];
            }[];
            quota: { [key: string]: unknown };
            require2FA: boolean;
            safeFields: string[];
            scrapeJavaScript: boolean;
            scrubIPAddresses: boolean;
            sensitiveFields: string[];
            slug: string;
            status: {
              id?: string;
              name?: string;
            };
            /** Format: int64 */
            storeCrashReports: number;
            teams: {
              avatar: {
                avatarType?: string;
                avatarUuid?: string | null;
              };
              /** Format: date-time */
              dateCreated: string;
              hasAccess: boolean;
              id: string;
              isMember: boolean;
              isPending: boolean;
              /** Format: int64 */
              memberCount: number;
              name: string;
              slug: string;
            }[];
            trustedRelays: string[];
          };
        };
      };
      /** Bad Input */
      400: unknown;
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional new name for the organization. */
          name: string;
          /** @description An optional new slug for the organization. Needs to be available and unique. */
          slug?: string;
        };
      };
    };
  };
  /** Return a list of version control repositories for a given organization. */
  "List an Organization's Repositories": {
    parameters: {
      path: {
        /** The organization short name. */
        organization_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            dateCreated: string;
            id: string;
            name: string;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Return a list of commits for a given repository. */
  "List a Repository's Commits": {
    parameters: {
      path: {
        /** The organization short name. */
        organization_slug: string;
        /** The repository ID. */
        repo_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** Format: date-time */
            dateCreated: string;
            id: string;
            message: string | null;
          }[];
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** This endpoint is deprecated in favor of [Organization Stats V2](/api/organizations/retrieve-event-counts-for-an-organization-v2/). */
  "Retrieve Event Counts for an Organization": {
    parameters: {
      path: {
        /** The slug of the organization the event ID should be looked up in. */
        organization_slug: string;
      };
      query: {
        /** The name of the stat to query `("received", "rejected", "blacklisted")`. */
        stat?: "received" | "rejected" | "blacklisted";
        /** A timestamp to set the start of the query in seconds since UNIX epoch. */
        since?: string;
        /** A timestamp to set the end of the query in seconds since UNIX epoch. */
        until?: string;
        /** An explicit resolution to search for (one of `10s`, `1h`, and `1d`). */
        resolution?: "10s" | "1h" | "1d";
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": number[][];
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /**
   * Returns a time series of release health session statistics for projects bound to an organization.
   *
   * The interval and date range are subject to certain restrictions and rounding rules.
   *
   * The date range is rounded to align with the interval, and is rounded to at least one hour. The interval can at most be one day and at least one hour currently. It has to cleanly divide one day, for rounding reasons.
   */
  "Retrieve Release Health Session Statistics": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
      };
      query: {
        /**
         * The ID of the projects to filter by.
         *
         * Use `-1` to include all accessible projects.
         */
        project: number[];
        /**
         * The list of fields to query.
         *
         * The available fields are `sum(session)`, `count_unique(user)`, and the following functions applied to the `session.duration` metric: `avg`, `p50`, `p75`, `p90`, `p95`, `p99` and `max`.
         *
         * For example, `p99(session.duration)`.
         */
        field: string[];
        /** The name of environments to filter by. */
        environment?: string[];
        /**
         * The list of properties to group by.
         *
         * The available groupBy conditions are `project`, `release`, `environment` and `session.status`.
         */
        groupBy?: string[];
        /**
         * A free-form query that is applied as a filter.
         *
         * An example query could be `release:"1.1.0" or release:"1.2.0"`.
         */
        query?: string;
        /**
         * This defines the range of the time series, relative to now.
         *
         * The range is given in a `"<number><unit>"` format.
         *
         * For example `1d` for a one day range. Possible units are `m` for minutes, `h` for hours, `d` for days and `w` for weeks.
         *
         * It defaults to `90d`.
         */
        statsPeriod?: string;
        /**
         * This is the resolution of the time series, given in the same format as `statsPeriod`.
         *
         * The default resolution is `1h` and the minimum resolution is currently restricted to `1h` as well.
         *
         * Intervals larger than `1d` are not supported, and the interval has to cleanly divide one day.
         */
        interval?: string;
        /** This defines the start of the time series range, in the same format as the `interval`, relative to now. */
        statsPeriodStart?: string;
        /** This defines the end of the time series range, in the same format as the `interval`, relative to now. */
        statsPeriodEnd?: string;
        /** This defines the start of the time series range as an explicit datetime. */
        start?: string;
        /** This defines the inclusive end of the time series range as an explicit datetime. */
        end?: string;
      };
    };
    responses: {
      /** Time-series Session Statistics. */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The start time of the data being returned.
             */
            start: string;
            /**
             * Format: date-time
             * @description The exclusive end time of the data being returned.
             */
            end: string;
            /** @description The time slices of the timeseries data given in the `groups[].series` field. */
            intervals: string[];
            groups: {
              /** @description These are key/value pairs, the key being the requested `groupBy` property with its corresponding value. */
              by: { [key: string]: unknown };
              /** @description These are key/value pairs, the key being the requested `field`, and the value the corresponding total over the requested time frame. */
              totals: { [key: string]: unknown };
              /** @description These are key/value pairs, the key being the requested `field`, and the value is an array of aggregated values. The array corresponds to the times given in the `intervals` array. */
              series: { [key: string]: number[] };
            }[];
          };
        };
      };
      /** Wrong Parameters */
      400: {
        content: {
          "application/json": {
            detail: string;
          };
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
    };
  };
  /** Return a list of users that belong to a given organization. */
  "List an Organization's Users": {
    parameters: {
      path: {
        /** The slug of the organization the event ID should be looked up in. */
        organization_slug: string;
      };
      query: {
        /** Restrict results to users who have access to a given project ID */
        project?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            dateCreated: string;
            user: {
              username: string;
              lastLogin: string | null;
              isSuperuser: boolean;
              isManaged: boolean;
              lastActive: string;
              isStaff: boolean;
              id: string;
              isActive: boolean;
              has2fa: boolean;
              name: string;
              avatarUrl: string;
              dateJoined: string;
              emails: {
                is_verified?: boolean;
                id?: string;
                email?: string;
              }[];
              avatar: {
                avatarType?: string;
                avatarUuid?: string | null;
              };
              hasPasswordAuth: boolean;
              email: string;
            };
            roleName: string;
            expired: boolean;
            id: string;
            projects: string[];
            name: string;
            /** @enum {string} */
            role: "owner" | "manager" | "admin" | "member" | "billing";
            flags: {
              "sso: linked"?: boolean;
              "sso: invalid"?: boolean;
            };
            email: string;
            pending: boolean;
          }[];
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** This resolves a short ID to the project slug and internal issue ID. */
  "Resolve a Short ID": {
    parameters: {
      path: {
        /** The slug of the organization the short ID should be looked up in. */
        organization_slug: string;
        /** The short ID to look up. */
        short_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            organizationSlug: string;
            projectSlug: string;
            shortId: string;
            group: {
              lastSeen: string;
              numComments: number;
              userCount: number;
              culprit: string | null;
              title: string;
              id: string;
              assignedTo: {
                type?: string;
                id?: string;
                name?: string;
              } | null;
              logger: string | null;
              type: string;
              annotations: string[];
              metadata: {
                function?: string;
                title?: string;
                type?: string;
                value?: string;
                filename?: string;
              };
              /** @enum {string} */
              status: "resolved" | "unresolved" | "ignored";
              subscriptionDetails: {
                reason?: string;
              } | null;
              isPublic: boolean;
              hasSeen: boolean;
              shortId: string;
              shareId: string | null;
              firstSeen: string;
              count: string;
              permalink: string;
              level: string;
              isSubscribed: boolean;
              isBookmarked: boolean;
              project: {
                slug?: string;
                id?: string;
                name?: string;
              };
              statusDetails: { [key: string]: unknown };
            };
            groupId: string;
          };
        };
      };
      /** Unauthorized */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Return a list of projects available to the authenticated session. */
  "List Your Projects": {
    parameters: {
      query: {
        /** A pointer to the last object fetched and its sort order; used to retrieve the next or previous results. */
        cursor?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            color: string;
            /** Format: date-time */
            dateCreated: string;
            features: string[];
            firstEvent: string | null;
            hasAccess: boolean;
            id: string;
            isBookmarked: boolean;
            isInternal: boolean;
            isMember: boolean;
            isPublic: boolean;
            name: string;
            organization: {
              avatar: {
                avatarType?: string;
                avatarUuid?: string | null;
              };
              /** Format: date-time */
              dateCreated: string;
              id: string;
              isEarlyAdopter: boolean;
              name: string;
              require2FA: boolean;
              slug: string;
              status: {
                id: string;
                name: string;
              };
            };
            platform: string | null;
            slug: string;
            /** @enum {string} */
            status:
              | "active"
              | "disabled"
              | "pending_deletion"
              | "deletion_in_progress";
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** Return details on an individual project. */
  "Retrieve a Project": {
    parameters: {
      path: {
        /** The slug of the organization the project belongs to. */
        organization_slug: string;
        /** The slug of the project to retrieve. */
        project_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            allowedDomains: string[];
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            color: string;
            dataScrubber: boolean;
            dataScrubberDefaults: boolean;
            dateCreated: string;
            defaultEnvironment: string | null;
            digestsMaxDelay: number;
            digestsMinDelay: number;
            features: string[];
            firstEvent: string | null;
            hasAccess: boolean;
            id: string;
            isBookmarked: boolean;
            isInternal: boolean;
            isMember: boolean;
            isPublic: boolean;
            latestRelease: {
              authors: {
                name?: string;
                email?: string;
              }[];
              commitCount: number;
              data: { [key: string]: unknown };
              dateCreated: string;
              dateReleased: string | null;
              deployCount: number;
              firstEvent: string | null;
              lastCommit: { [key: string]: unknown } | null;
              lastDeploy: { [key: string]: unknown } | null;
              lastEvent: string | null;
              newGroups: number;
              owner: string | null;
              projects: {
                name?: string;
                slug?: string;
              }[];
              ref: string | null;
              shortVersion: string;
              url: string | null;
              version: string;
            } | null;
            name: string;
            options: {
              "feedback:branding"?: boolean;
              "filters:blacklisted_ips"?: string;
              "filters:error_messages"?: string;
              "filters:releases"?: string;
              "sentry:csp_ignored_sources"?: string;
              "sentry:csp_ignored_sources_defaults"?: boolean;
              "sentry:reprocessing_active"?: boolean;
            };
            organization: {
              avatar: {
                avatarType?: string;
                avatarUuid?: string | null;
              };
              /** Format: date-time */
              dateCreated: string;
              id: string;
              isEarlyAdopter: boolean;
              name: string;
              require2FA: boolean;
              slug: string;
              status: {
                id: string;
                name: string;
              };
            };
            platform: string | null;
            platforms: string[];
            plugins?: {
              assets: string[];
              author?: {
                name?: string;
                url?: string;
              } | null;
              canDisable: boolean;
              contexts: string[];
              description?: string;
              doc: string;
              enabled: boolean;
              hasConfiguration: boolean;
              id: string;
              isTestable: boolean;
              metadata: { [key: string]: unknown };
              name: string;
              resourceLinks?:
                | {
                    title?: string;
                    url?: string;
                  }[]
                | null;
              shortName: string;
              slug: string;
              status: string;
              type: string;
              version?: string | null;
            }[];
            processingIssues: number;
            relayPiiConfig: string | null;
            resolveAge: number;
            safeFields: string[];
            scrapeJavaScript: boolean;
            scrubIPAddresses: boolean;
            securityToken: string;
            securityTokenHeader: string | null;
            sensitiveFields: string[];
            slug: string;
            status: string;
            storeCrashReports: boolean | null;
            subjectPrefix: string;
            subjectTemplate: string;
            team: {
              id: string;
              name: string;
              slug: string;
            };
            teams: {
              id: string;
              name: string;
              slug: string;
            }[];
            verifySSL: boolean;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** Project not found */
      404: unknown;
    };
  };
  /** Update various attributes and configurable settings for the given project.  Only supplied values are updated. */
  "Update a Project": {
    parameters: {
      path: {
        /** The slug of the organization the project belongs to. */
        organization_slug: string;
        /** The slug of the project to update. */
        project_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            allowedDomains: string[];
            avatar: {
              avatarType?: string;
              avatarUuid?: string | null;
            };
            color: string;
            dataScrubber: boolean;
            dataScrubberDefaults: boolean;
            dateCreated: string;
            defaultEnvironment: string | null;
            digestsMaxDelay: number;
            digestsMinDelay: number;
            features: string[];
            firstEvent: string | null;
            hasAccess: boolean;
            id: string;
            isBookmarked: boolean;
            isInternal: boolean;
            isMember: boolean;
            isPublic: boolean;
            latestRelease: {
              authors: {
                name?: string;
                email?: string;
              }[];
              commitCount: number;
              data: { [key: string]: unknown };
              dateCreated: string;
              dateReleased: string | null;
              deployCount: number;
              firstEvent: string | null;
              lastCommit: { [key: string]: unknown } | null;
              lastDeploy: { [key: string]: unknown } | null;
              lastEvent: string | null;
              newGroups: number;
              owner: string | null;
              projects: {
                name?: string;
                slug?: string;
              }[];
              ref: string | null;
              shortVersion: string;
              url: string | null;
              version: string;
            } | null;
            name: string;
            options: {
              "feedback:branding"?: boolean;
              "filters:blacklisted_ips"?: string;
              "filters:error_messages"?: string;
              "filters:releases"?: string;
              "sentry:csp_ignored_sources"?: string;
              "sentry:csp_ignored_sources_defaults"?: boolean;
              "sentry:reprocessing_active"?: boolean;
            };
            organization: {
              avatar: {
                avatarType?: string;
                avatarUuid?: string | null;
              };
              /** Format: date-time */
              dateCreated: string;
              id: string;
              isEarlyAdopter: boolean;
              name: string;
              require2FA: boolean;
              slug: string;
              status: {
                id: string;
                name: string;
              };
            };
            platform: string | null;
            platforms: string[];
            plugins?: {
              assets: string[];
              author?: {
                name?: string;
                url?: string;
              } | null;
              canDisable: boolean;
              contexts: string[];
              description?: string;
              doc: string;
              enabled: boolean;
              hasConfiguration: boolean;
              id: string;
              isTestable: boolean;
              metadata: { [key: string]: unknown };
              name: string;
              resourceLinks?:
                | {
                    title?: string;
                    url?: string;
                  }[]
                | null;
              shortName: string;
              slug: string;
              status: string;
              type: string;
              version?: string | null;
            }[];
            processingIssues: number;
            relayPiiConfig: string | null;
            resolveAge: number;
            safeFields: string[];
            scrapeJavaScript: boolean;
            scrubIPAddresses: boolean;
            securityToken: string;
            securityTokenHeader: string | null;
            sensitiveFields: string[];
            slug: string;
            status: string;
            storeCrashReports: boolean | null;
            subjectPrefix: string;
            subjectTemplate: string;
            team: {
              id: string;
              name: string;
              slug: string;
            };
            teams: {
              id: string;
              name: string;
              slug: string;
            }[];
            verifySSL: boolean;
          };
        };
      };
      /** Bad Input */
      400: unknown;
      /** Forbidden */
      403: unknown;
      /** Project not found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The new name for the project. */
          name?: string;
          /** @description The new slug for the project. */
          slug?: string;
          /** @description The new platform for the project. */
          platform?: string;
          /** @description In case this API call is invoked with a user context this allows changing of the bookmark flag. */
          isBookmarked?: boolean;
          digestsMinDelay?: number;
          digestsMaxDelay?: number;
        };
      };
    };
  };
  /**
   * Schedules a project for deletion.
   *
   * Deletion happens asynchronously and therefore is not immediate.
   * However once deletion has begun the state of a project changes and
   * will be hidden from most public views.
   */
  "Delete a Project": {
    parameters: {
      path: {
        /** The slug of the organization the project belongs to. */
        organization_slug: string;
        /** The slug of the project to delete. */
        project_slug: string;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Forbidden */
      403: unknown;
      /** Project not found */
      404: unknown;
    };
  };
  /** Retrieve a list of debug information files for a given project. */
  "List a Project's Debug Information Files": {
    parameters: {
      path: {
        /** The slug of the organization the file belongs to. */
        organization_slug: string;
        /** The slug of the project to list the DIFs of. */
        project_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
  };
  /**
   * Upload a new debug information file for the given release.
   *
   * Unlike other API requests, files must be uploaded using the
   * traditional multipart/form-data content-type.
   *
   * The file uploaded is a zip archive of an Apple .dSYM folder which
   * contains the individual debug images.  Uploading through this endpoint
   * will create different files for the contained images.
   */
  "Upload a New File": {
    parameters: {
      path: {
        /** The slug of the organization the project belongs to. */
        organization_slug: string;
        /** The slug of the project to upload a file to. */
        project_slug: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": unknown;
        };
      };
      /** Bad Input */
      400: unknown;
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The multipart encoded file.
           */
          file: string;
        };
      };
    };
  };
  /** Delete a debug information file for a given project. */
  "Delete a Specific Project's Debug Information File": {
    parameters: {
      path: {
        /** The slug of the organization the file belongs to. */
        organization_slug: string;
        /** The slug of the project to delete the DIF. */
        project_slug: string;
      };
      query: {
        /** The ID of the DIF to delete. */
        id: string;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
  };
  /** Return a list of users seen within this project. */
  "List a Project's Users": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
      };
      query: {
        /** Limit results to users matching the given query. Prefixes should be used to suggest the field to match on: `id`, `email`, `username`, `ip`. For example, `query=email:foo@example.com` */
        query?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            dateCreated: string;
            id: string;
            username: string | null;
            email: string | null;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /**
   * Return a list of values associated with this key.  The `query`
   * parameter can be used to to perform a "contains" match on
   * values.
   *
   * When [paginated](/api/pagination) can return at most 1000 values.
   */
  "List a Tag's Values": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
        /** The tag key to look up. */
        key: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            name: string;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /**
   * Return a set of points representing a normalized timestamp and the
   * number of events seen in the period.
   *
   * Query ranges are limited to Sentry's configured time-series resolutions.
   */
  "Retrieve Event Counts for a Project": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
      };
      query: {
        /** The name of the stat to query `("received", "rejected", "blacklisted", "generated")`. */
        stat?: "received" | "rejected" | "blacklisted" | "generated";
        /** A timestamp to set the start of the query in seconds since UNIX epoch. */
        since?: string;
        /** A timestamp to set the end of the query in seconds since UNIX epoch. */
        until?: string;
        /** An explicit resolution to search for (one of `10s`, `1h`, and `1d`). */
        resolution?: "10s" | "1h" | "1d";
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": number[][];
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** Return a list of user feedback items within this project. */
  "List a Project's User Feedback": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            comments: string;
            dateCreated: string;
            email: string;
            event: {
              eventID?: string;
              id?: string | null;
            };
            eventID: string;
            id: string;
            issue: { [key: string]: unknown } | null;
            name: string;
            user: { [key: string]: unknown } | null;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /**
   * Submit and associate user feedback with an issue.
   *
   * Feedback must be received by the server no more than 30 minutes after the event was saved.
   *
   * Additionally, within 5 minutes of submitting feedback it may also be overwritten. This is useful in situations where you may need to retry sending a request due to network failures.
   *
   * If feedback is rejected due to a mutability threshold, a 409 status code will be returned.
   *
   * Note: Feedback may be submitted with DSN authentication (see auth documentation).
   */
  "Submit User Feedback": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            comments: string;
            dateCreated: string;
            email: string;
            event: {
              eventID?: string;
              id?: string | null;
            };
            eventID: string;
            id: string;
            issue: { [key: string]: unknown } | null;
            name: string;
            user: { [key: string]: unknown } | null;
          };
        };
      };
      /** Bad Input */
      400: unknown;
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
      /** Conflict */
      409: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The event ID. This can be retrieved from the [beforeSend callback](https://docs.sentry.io/platforms/javascript/configuration/filtering/#using-beforesend). */
          event_id: string;
          /** @description User's name. */
          name: string;
          /** @description User's email address. */
          email: string;
          /** @description Comments supplied by user. */
          comments: string;
        };
      };
    };
  };
  /** Return a list of client keys bound to a project. */
  "List a Project's Client Keys": {
    parameters: {
      path: {
        /** The slug of the organization the client keys belong to. */
        organization_slug: string;
        /** The slug of the project the client keys belong to. */
        project_slug: string;
      };
      query: {
        /** A pointer to the last object fetched and its sort order; used to retrieve the next or previous results. */
        cursor?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            browserSdk: {
              choices?: string[][];
            };
            browserSdkVersion: string;
            dateCreated: string;
            dsn: {
              cdn: string;
              csp: string;
              minidump: string;
              public: string;
              secret: string;
              security: string;
            };
            id: string;
            isActive: boolean;
            label: string;
            name: string;
            projectId: number;
            public: string;
            rateLimit: string | null;
            secret: string;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** Create a new client key bound to a project.  The key's secret and public key are generated by the server. */
  "Create a New Client Key": {
    parameters: {
      path: {
        /** The slug of the organization the client keys belong to. */
        organization_slug: string;
        /** The slug of the project the client keys belong to. */
        project_slug: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            browserSdk: {
              choices?: string[][];
            };
            browserSdkVersion: string;
            dateCreated: string;
            dsn: {
              cdn: string;
              csp: string;
              minidump: string;
              public: string;
              secret: string;
              security: string;
            };
            id: string;
            isActive: boolean;
            label: string;
            name: string;
            projectId: number;
            public: string;
            rateLimit: string | null;
            secret: string;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The name for the new key. */
          name: string;
        };
      };
    };
  };
  /** Update a client key.  This can be used to rename a key. */
  "Update a Client Key": {
    parameters: {
      path: {
        /** The slug of the organization the client keys belong to. */
        organization_slug: string;
        /** The slug of the project the client keys belong to. */
        project_slug: string;
        /** The ID of the key to update. */
        key_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            browserSdk: {
              choices?: string[][];
            };
            browserSdkVersion: string;
            dateCreated: string;
            dsn: {
              cdn: string;
              csp: string;
              minidump: string;
              public: string;
              secret: string;
              security: string;
            };
            id: string;
            isActive: boolean;
            label: string;
            name: string;
            projectId: number;
            public: string;
            rateLimit: string | null;
            secret: string;
          };
        };
      };
      /** Bad Input */
      400: unknown;
      /** Forbidden */
      403: unknown;
      /** Project not found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The new name for the client key. */
          name?: string;
        };
      };
    };
  };
  /** Delete a client key. */
  "Delete a Client Key": {
    parameters: {
      path: {
        /** The slug of the organization the client keys belong to. */
        organization_slug: string;
        /** The slug of the project the client keys belong to. */
        project_slug: string;
        /** The ID of the key to delete. */
        key_id: string;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Forbidden */
      403: unknown;
      /** Project not found */
      404: unknown;
    };
  };
  /** Return a list of service hooks bound to a project. */
  "List a Project's Service Hooks": {
    parameters: {
      path: {
        /** The slug of the organization the client keys belong to. */
        organization_slug: string;
        /** The slug of the project the client keys belong to. */
        project_slug: string;
      };
      query: {
        /** A pointer to the last object fetched and its sort order; used to retrieve the next or previous results. */
        cursor?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            dateCreated: string;
            events: string[];
            id: string;
            secret: string;
            status: string;
            url: string;
          }[];
        };
      };
      /** You do not have that feature enabled */
      403: unknown;
    };
  };
  /**
   * Register a new service hook on a project.
   *
   * Events include:
   *
   * - event.alert: An alert is generated for an event (via rules).
   * - event.created: A new event has been processed.
   *
   * This endpoint requires the 'servicehooks' feature to be enabled for your project.
   */
  "Register a New Service Hook": {
    parameters: {
      path: {
        /** The slug of the organization the client keys belong to. */
        organization_slug: string;
        /** The slug of the project the client keys belong to. */
        project_slug: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            dateCreated: string;
            events: string[];
            id: string;
            secret: string;
            status: string;
            url: string;
          };
        };
      };
      /** You do not have that feature enabled */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The URL for the webhook. */
          url: string;
          /** @description The events to subscribe to. */
          events: string[];
        };
      };
    };
  };
  /** Return a service hook bound to a project. */
  "Retrieve a Service Hook": {
    parameters: {
      path: {
        /** The slug of the organization the client keys belong to. */
        organization_slug: string;
        /** The slug of the project the client keys belong to. */
        project_slug: string;
        /** The GUID of the service hook. */
        hook_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            dateCreated: string;
            events: string[];
            id: string;
            secret: string;
            status: string;
            url: string;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
  };
  /** Update a service hook. */
  "Update a Service Hook": {
    parameters: {
      path: {
        /** The slug of the organization the client keys belong to. */
        organization_slug: string;
        /** The slug of the project the client keys belong to. */
        project_slug: string;
        /** The GUID of the service hook. */
        hook_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            dateCreated: string;
            events: string[];
            id: string;
            secret: string;
            status: string;
            url: string;
          };
        };
      };
      /** Bad Input */
      400: unknown;
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The URL for the webhook. */
          url: string;
          /** @description The events to subscribe to. */
          events: string[];
        };
      };
    };
  };
  /** Remove a service hook. */
  "Remove a Service Hook": {
    parameters: {
      path: {
        /** The slug of the organization the client keys belong to. */
        organization_slug: string;
        /** The slug of the project the client keys belong to. */
        project_slug: string;
        /** The GUID of the service hook. */
        hook_id: string;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
  };
  /** Return details on an individual event. */
  "Retrieve an Event for a Project": {
    parameters: {
      path: {
        /** The slug of the organization the event belongs to. */
        organization_slug: string;
        /** The slug of the project the event belongs to. */
        project_slug: string;
        /** The ID of the event to retrieve. It is the hexadecimal ID as reported by the client. */
        event_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            eventID: string;
            dist: string | null;
            userReport: { [key: string]: unknown } | null;
            previousEventID: string | null;
            message: string;
            id: string;
            size: number;
            errors: {
              message?: string;
              type?: string;
              data?: { [key: string]: unknown };
            }[];
            platform: string;
            nextEventID: string | null;
            type: string;
            metadata:
              | {
                  type: string;
                  value: string;
                }
              | {
                  title: string;
                };
            tags: {
              value?: string;
              key?: string;
              _meta?: string | null;
            }[];
            dateCreated: string;
            dateReceived: string;
            user: {
              username: string | null;
              name: string | null;
              ip_address: string | null;
              email: string | null;
              data: {
                isStaff?: boolean;
              } | null;
              id: string;
            } | null;
            entries: (Partial<{
              type: string;
              data: {
                values: {
                  category: string;
                  level: string;
                  event_id: string | null;
                  /** Format: date-time */
                  timestamp: string;
                  data: { [key: string]: unknown } | null;
                  message: string | null;
                  type: string;
                }[];
              };
            }> &
              Partial<{
                type: string;
                data: {
                  fragment: string | null;
                  cookies: string[][] | null;
                  inferredContentType: string | null;
                  env: {
                    ENV?: string;
                  } | null;
                  headers: string[][];
                  url: string;
                  query: string[][];
                  data: { [key: string]: unknown } | null;
                  method: string | null;
                };
              }> &
              Partial<{
                type: string;
                data: {
                  formatted: string;
                };
              }> &
              Partial<{
                type: string;
                data: {
                  excOmitted: number[] | null;
                  hasSystemFrames: boolean;
                  values: {
                    stacktrace: {
                      frames: {
                        function: string;
                        errors: string | null;
                        colNo: number | null;
                        vars: { [key: string]: unknown } | null;
                        package: string | null;
                        absPath: string | null;
                        inApp: boolean;
                        lineNo: number;
                        module: string;
                        filename: string;
                        platform: string | null;
                        instructionAddr: string | null;
                        context: (number | string)[][];
                        symbolAddr: string | null;
                        trust: string | null;
                        symbol: string | null;
                      }[];
                      framesOmitted: string | null;
                      registers: string | null;
                      hasSystemFrames: boolean;
                    } | null;
                    module: string | null;
                    rawStacktrace: { [key: string]: unknown } | null;
                    mechanism: {
                      type?: string;
                      handled?: boolean;
                    } | null;
                    threadId: string | null;
                    value: string;
                    type: string;
                  }[];
                };
              }>)[];
            packages: { [key: string]: unknown };
            sdk: {
              version?: string;
              name?: string;
            };
            _meta: {
              user?: string | null;
              context?: string | null;
              entries?: { [key: string]: unknown };
              contexts?: string | null;
              message?: string | null;
              packages?: string | null;
              tags?: { [key: string]: unknown };
              sdk?: string | null;
            };
            contexts: { [key: string]: unknown };
            fingerprints: string[];
            context: { [key: string]: unknown };
            release:
              | (
                  | {
                      authors: { [key: string]: unknown }[];
                      /** Format: int64 */
                      commitCount: number;
                      data: { [key: string]: unknown };
                      /** Format: date-time */
                      dateCreated: string;
                      /** Format: date-time */
                      dateReleased: string | null;
                      /** Format: int64 */
                      deployCount: number;
                      /** Format: date-time */
                      firstEvent: string | null;
                      lastCommit: { [key: string]: unknown } | null;
                      lastDeploy:
                        | (
                            | {
                                environment: string;
                                name: string | null;
                                /** Format: date-time */
                                dateStarted: string | null;
                                /** Format: date-time */
                                dateFinished: string;
                                url: string | null;
                                id: string;
                              }
                            | (unknown | null)
                          )
                        | null;
                      /** Format: date-time */
                      lastEvent: string | null;
                      /** Format: int64 */
                      newGroups: number;
                      owner: { [key: string]: unknown } | null;
                      projects: {
                        name?: string;
                        slug?: string;
                      }[];
                      ref: string | null;
                      shortVersion: string;
                      version: string;
                      url: string | null;
                    }
                  | (unknown | null)
                )
              | null;
            groupID: string;
            title: string;
          };
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** Return a list of events bound to a project. */
  "List a Project's Events": {
    parameters: {
      path: {
        /** The slug of the organization the groups belong to. */
        organization_slug: string;
        /** The slug of the project the groups belong to. */
        project_slug: string;
      };
      query: {
        /**
         * If this is set to true then the event payload will include the full event body, including the stacktrace.
         * Set to true to enable.
         */
        full?: boolean;
        /** A pointer to the last object fetched and its sort order; used to retrieve the next or previous results. */
        cursor?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            eventID: string;
            tags: {
              value?: string;
              key?: string;
            }[];
            dateCreated: string;
            user: {
              username: string | null;
              name: string | null;
              ip_address: string | null;
              email: string | null;
              data: {
                isStaff?: boolean;
              } | null;
              id: string;
            } | null;
            message: string;
            id: string;
            platform: string;
            "event.type": string;
            groupID: string;
            title: string;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /**
   * Return a list of issues (groups) bound to a project.  All parameters are supplied as query string parameters.
   *
   *  A default query of ``is:unresolved`` is applied. To return results with other statuses send an new query value (i.e. ``?query=`` for all results).
   *
   * The ``statsPeriod`` parameter can be used to select the timeline stats which should be present. Possible values are: ``""`` (disable),``"24h"``, ``"14d"``
   */
  "List a Project's Issues": {
    parameters: {
      path: {
        /** The slug of the organization the issues belong to. */
        organization_slug: string;
        /** The slug of the project the issues belong to. */
        project_slug: string;
      };
      query: {
        /** An optional stat period (can be one of `"24h"`, `"14d"`, and `""`). */
        statsPeriod?: string;
        /** If this is set to true then short IDs are looked up by this function as well. This can cause the return value of the function to return an event issue of a different project which is why this is an opt-in. Set to 1 to enable. */
        shortIdLookup?: boolean;
        /** An optional Sentry structured search query. If not provided an implied `"is:unresolved"` is assumed. */
        query?: string;
        /** A pointer to the last object fetched and its sort order; used to retrieve the next or previous results. */
        cursor?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            annotations: string[];
            assignedTo: { [key: string]: unknown } | null;
            count: string;
            culprit: string;
            firstSeen: string;
            hasSeen: boolean;
            id: string;
            isBookmarked: boolean;
            isPublic: boolean;
            isSubscribed: boolean;
            lastSeen: string;
            level: string;
            logger: string | null;
            metadata:
              | {
                  filename: string;
                  type: string;
                  value: string;
                }
              | {
                  title: string;
                };
            numComments: number;
            permalink: string;
            project: {
              id?: string;
              name?: string;
              slug?: string;
            };
            shareId: string | null;
            shortId: string;
            stats: {
              "24h"?: number[][];
            };
            /** @enum {string} */
            status: "resolved" | "unresolved" | "ignored";
            statusDetails: { [key: string]: unknown };
            subscriptionDetails: { [key: string]: unknown } | null;
            title: string;
            type: string;
            userCount: number;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /**
   * Bulk mutate various attributes on issues.  The list of issues to modify is given through the `id` query parameter.  It is repeated for each issue that should be modified.
   *
   * - For non-status updates, the `id` query parameter is required.
   * - For status updates, the `id` query parameter may be omitted
   * for a batch "update all" query.
   * - An optional `status` query parameter may be used to restrict
   * mutations to only events with the given status.
   *
   * The following attributes can be modified and are supplied as JSON object in the body:
   *
   * If any ids are out of scope this operation will succeed without any data mutation.
   */
  "Bulk Mutate a List of Issues": {
    parameters: {
      path: {
        /** The slug of the organization the issues belong to. */
        organization_slug: string;
        /** The slug of the project the issues belong to. */
        project_slug: string;
      };
      query: {
        /** A list of IDs of the issues to be mutated. This parameter shall be repeated for each issue. It is optional only if a status is mutated in which case an implicit update all is assumed. */
        id?: number;
        /** Optionally limits the query to issues of the specified status. Valid values are `"resolved"`, `"unresolved"`, and `"ignored"`. */
        status?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            isPublic: boolean;
            /** @enum {string} */
            status: "resolved" | "unresolved" | "ignored";
            statusDetails: { [key: string]: unknown };
          };
        };
      };
      /** Bad Input */
      400: unknown;
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The new status for the issues. Valid values are `"resolved"`, `"resolvedInNextRelease"`, `"unresolved"`, and `"ignored"`. */
          status?: string;
          /** @description Additional details about the resolution. Valid values are `"inRelease"`, `"inNextRelease"`, `"inCommit"`, `"ignoreDuration"`, `"ignoreCount"`, `"ignoreWindow"`, `"ignoreUserCount"`, and `"ignoreUserWindow"`. */
          statusDetails?: {
            inRelease?: string;
            inNextRelease?: boolean;
            inCommit?: string;
            ignoreDuration?: number;
            ignoreCount?: number;
            ignoreWindow?: number;
            ignoreUserCount?: number;
            ignoreUserWindow?: number;
          };
          /** @description The number of minutes to ignore this issue. */
          ignoreDuration?: number;
          /** @description Sets the issue to public or private. */
          isPublic?: boolean;
          /** @description Allows to merge or unmerge different issues. */
          merge?: boolean;
          /** @description The actor id (or username) of the user or team that should be assigned to this issue. */
          assignedTo?: string;
          /** @description In case this API call is invoked with a user context this allows changing of the flag that indicates if the user has seen the event. */
          hasSeen?: boolean;
          /** @description In case this API call is invoked with a user context this allows changing of the bookmark flag. */
          isBookmarked?: boolean;
        };
      };
    };
  };
  /**
   * Permanently remove the given issues. The list of issues to modify is given through the `id` query parameter.  It is repeated for each issue that should be removed.
   *
   * Only queries by 'id' are accepted.
   *
   * If any ids are out of scope this operation will succeed without any data mutation.
   */
  "Bulk Remove a List of Issues": {
    parameters: {
      path: {
        /** The slug of the organization the issues belong to. */
        organization_slug: string;
        /** The slug of the project the issues belong to. */
        project_slug: string;
      };
      query: {
        /** A list of IDs of the issues to be removed. This parameter shall be repeated for each issue. */
        id?: number;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Forbidden */
      403: unknown;
      /** Project not found */
      404: unknown;
    };
  };
  /**
   * Returns details for given tag key related to an issue.
   *
   * When [paginated](/api/pagination) can return at most 1000 values.
   */
  "List a Tag's Values Related to an Issue": {
    parameters: {
      path: {
        /** The ID of the issue to retrieve. */
        issue_id: string;
        /** The tag key to look the values up for. */
        key: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            key: string;
            value: string;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** Returns details for given tag key related to an issue. */
  "Retrieve Tag Details": {
    parameters: {
      path: {
        /** The ID of the issue to retrieve. */
        issue_id: string;
        /** The tag key to look the values up for. */
        key: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            key: string;
            totalValues: number;
          };
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** This endpoint lists an issue's hashes, which are the generated checksums used to aggregate individual events. */
  "List an Issue's Hashes": {
    parameters: {
      path: {
        /** The ID of the issue to retrieve. */
        issue_id: string;
      };
      query: {
        /** A pointer to the last object fetched and its sort order; used to retrieve the next or previous results. */
        cursor?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            latestEvent?: {
              eventID: string;
              dist: string | null;
              message: string;
              id: string;
              size: number;
              errors: {
                message?: string;
                type?: string;
                data?: { [key: string]: unknown };
              }[];
              platform: string;
              type: string;
              metadata:
                | {
                    type: string;
                    value: string;
                  }
                | {
                    title: string;
                  };
              tags: {
                value?: string;
                key?: string;
                _meta?: string | null;
              }[];
              dateCreated: string;
              dateReceived: string;
              user: {
                username: string | null;
                name: string | null;
                ip_address: string | null;
                email: string | null;
                data: {
                  isStaff?: boolean;
                } | null;
                id: string;
              } | null;
              entries: (Partial<{
                type: string;
                data: {
                  values: {
                    category: string;
                    level: string;
                    event_id: string | null;
                    /** Format: date-time */
                    timestamp: string;
                    data: { [key: string]: unknown } | null;
                    message: string | null;
                    type: string;
                  }[];
                };
              }> &
                Partial<{
                  type: string;
                  data: {
                    fragment: string | null;
                    cookies: string[][] | null;
                    inferredContentType: string | null;
                    env: {
                      ENV?: string;
                    } | null;
                    headers: string[][];
                    url: string;
                    query: string[][];
                    data: { [key: string]: unknown } | null;
                    method: string | null;
                  };
                }> &
                Partial<{
                  type: string;
                  data: {
                    formatted: string;
                  };
                }> &
                Partial<{
                  type: string;
                  data: {
                    excOmitted: number[] | null;
                    hasSystemFrames: boolean;
                    values: {
                      stacktrace: {
                        frames: {
                          function: string;
                          errors: string | null;
                          colNo: number | null;
                          vars: { [key: string]: unknown } | null;
                          package: string | null;
                          absPath: string | null;
                          inApp: boolean;
                          lineNo: number;
                          module: string;
                          filename: string;
                          platform: string | null;
                          instructionAddr: string | null;
                          context: (number | string)[][];
                          symbolAddr: string | null;
                          trust: string | null;
                          symbol: string | null;
                        }[];
                        framesOmitted: string | null;
                        registers: string | null;
                        hasSystemFrames: boolean;
                      } | null;
                      module: string | null;
                      rawStacktrace: { [key: string]: unknown } | null;
                      mechanism: {
                        type?: string;
                        handled?: boolean;
                      } | null;
                      threadId: string | null;
                      value: string;
                      type: string;
                    }[];
                  };
                }>)[];
              packages: { [key: string]: unknown };
              sdk: {
                version?: string;
                name?: string;
              };
              _meta: {
                user?: string | null;
                context?: string | null;
                entries?: { [key: string]: unknown };
                contexts?: string | null;
                message?: string | null;
                packages?: string | null;
                tags?: { [key: string]: unknown };
                sdk?: string | null;
              };
              contexts: { [key: string]: unknown };
              fingerprints: string[];
              context: { [key: string]: unknown };
              groupID: string;
              title: string;
            };
            id?: string;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** Retrieves the details of the oldest event for an issue. */
  "Retrieve the Oldest Event for an Issue": {
    parameters: {
      path: {
        /** The ID of the issue. */
        issue_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            eventID: string;
            dist: string | null;
            userReport: { [key: string]: unknown } | null;
            previousEventID: string | null;
            message: string;
            id: string;
            size: number;
            errors: {
              message?: string;
              type?: string;
              data?: { [key: string]: unknown };
            }[];
            platform: string;
            nextEventID: string | null;
            type: string;
            metadata:
              | {
                  type: string;
                  value: string;
                }
              | {
                  title: string;
                };
            tags: {
              value?: string;
              key?: string;
              _meta?: string | null;
            }[];
            dateCreated: string;
            dateReceived: string;
            user: {
              username: string | null;
              name: string | null;
              ip_address: string | null;
              email: string | null;
              data: {
                isStaff?: boolean;
              } | null;
              id: string;
            } | null;
            entries: (Partial<{
              type: string;
              data: {
                values: {
                  category: string;
                  level: string;
                  event_id: string | null;
                  /** Format: date-time */
                  timestamp: string;
                  data: { [key: string]: unknown } | null;
                  message: string | null;
                  type: string;
                }[];
              };
            }> &
              Partial<{
                type: string;
                data: {
                  fragment: string | null;
                  cookies: string[][] | null;
                  inferredContentType: string | null;
                  env: {
                    ENV?: string;
                  } | null;
                  headers: string[][];
                  url: string;
                  query: string[][];
                  data: { [key: string]: unknown } | null;
                  method: string | null;
                };
              }> &
              Partial<{
                type: string;
                data: {
                  formatted: string;
                };
              }> &
              Partial<{
                type: string;
                data: {
                  excOmitted: number[] | null;
                  hasSystemFrames: boolean;
                  values: {
                    stacktrace: {
                      frames: {
                        function: string;
                        errors: string | null;
                        colNo: number | null;
                        vars: { [key: string]: unknown } | null;
                        package: string | null;
                        absPath: string | null;
                        inApp: boolean;
                        lineNo: number;
                        module: string;
                        filename: string;
                        platform: string | null;
                        instructionAddr: string | null;
                        context: (number | string)[][];
                        symbolAddr: string | null;
                        trust: string | null;
                        symbol: string | null;
                      }[];
                      framesOmitted: string | null;
                      registers: string | null;
                      hasSystemFrames: boolean;
                    } | null;
                    module: string | null;
                    rawStacktrace: { [key: string]: unknown } | null;
                    mechanism: {
                      type?: string;
                      handled?: boolean;
                    } | null;
                    threadId: string | null;
                    value: string;
                    type: string;
                  }[];
                };
              }>)[];
            packages: { [key: string]: unknown };
            sdk: {
              version?: string;
              name?: string;
            };
            _meta: {
              user?: string | null;
              context?: string | null;
              entries?: { [key: string]: unknown };
              contexts?: string | null;
              message?: string | null;
              packages?: string | null;
              tags?: { [key: string]: unknown };
              sdk?: string | null;
            };
            contexts: { [key: string]: unknown };
            fingerprints: string[];
            context: { [key: string]: unknown };
            release:
              | (
                  | {
                      authors: { [key: string]: unknown }[];
                      /** Format: int64 */
                      commitCount: number;
                      data: { [key: string]: unknown };
                      /** Format: date-time */
                      dateCreated: string;
                      /** Format: date-time */
                      dateReleased: string | null;
                      /** Format: int64 */
                      deployCount: number;
                      /** Format: date-time */
                      firstEvent: string | null;
                      lastCommit: { [key: string]: unknown } | null;
                      lastDeploy:
                        | (
                            | {
                                environment: string;
                                name: string | null;
                                /** Format: date-time */
                                dateStarted: string | null;
                                /** Format: date-time */
                                dateFinished: string;
                                url: string | null;
                                id: string;
                              }
                            | (unknown | null)
                          )
                        | null;
                      /** Format: date-time */
                      lastEvent: string | null;
                      /** Format: int64 */
                      newGroups: number;
                      owner: { [key: string]: unknown } | null;
                      projects: {
                        name?: string;
                        slug?: string;
                      }[];
                      ref: string | null;
                      shortVersion: string;
                      version: string;
                      url: string | null;
                    }
                  | (unknown | null)
                )
              | null;
            groupID: string;
            title: string;
          };
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** Retrieves the details of the latest event for an issue. */
  "Retrieve the Latest Event for an Issue": {
    parameters: {
      path: {
        /** The ID of the issue. */
        issue_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            eventID: string;
            dist: string | null;
            userReport: { [key: string]: unknown } | null;
            previousEventID: string | null;
            message: string;
            id: string;
            size: number;
            errors: {
              message?: string;
              type?: string;
              data?: { [key: string]: unknown };
            }[];
            platform: string;
            nextEventID: string | null;
            type: string;
            metadata:
              | {
                  type: string;
                  value: string;
                }
              | {
                  title: string;
                };
            tags: {
              value?: string;
              key?: string;
              _meta?: string | null;
            }[];
            dateCreated: string;
            dateReceived: string;
            user: {
              username: string | null;
              name: string | null;
              ip_address: string | null;
              email: string | null;
              data: {
                isStaff?: boolean;
              } | null;
              id: string;
            } | null;
            entries: (Partial<{
              type: string;
              data: {
                values: {
                  category: string;
                  level: string;
                  event_id: string | null;
                  /** Format: date-time */
                  timestamp: string;
                  data: { [key: string]: unknown } | null;
                  message: string | null;
                  type: string;
                }[];
              };
            }> &
              Partial<{
                type: string;
                data: {
                  fragment: string | null;
                  cookies: string[][] | null;
                  inferredContentType: string | null;
                  env: {
                    ENV?: string;
                  } | null;
                  headers: string[][];
                  url: string;
                  query: string[][];
                  data: { [key: string]: unknown } | null;
                  method: string | null;
                };
              }> &
              Partial<{
                type: string;
                data: {
                  formatted: string;
                };
              }> &
              Partial<{
                type: string;
                data: {
                  excOmitted: number[] | null;
                  hasSystemFrames: boolean;
                  values: {
                    stacktrace: {
                      frames: {
                        function: string;
                        errors: string | null;
                        colNo: number | null;
                        vars: { [key: string]: unknown } | null;
                        package: string | null;
                        absPath: string | null;
                        inApp: boolean;
                        lineNo: number;
                        module: string;
                        filename: string;
                        platform: string | null;
                        instructionAddr: string | null;
                        context: (number | string)[][];
                        symbolAddr: string | null;
                        trust: string | null;
                        symbol: string | null;
                      }[];
                      framesOmitted: string | null;
                      registers: string | null;
                      hasSystemFrames: boolean;
                    } | null;
                    module: string | null;
                    rawStacktrace: { [key: string]: unknown } | null;
                    mechanism: {
                      type?: string;
                      handled?: boolean;
                    } | null;
                    threadId: string | null;
                    value: string;
                    type: string;
                  }[];
                };
              }>)[];
            packages: { [key: string]: unknown };
            sdk: {
              version?: string;
              name?: string;
            };
            _meta: {
              user?: string | null;
              context?: string | null;
              entries?: { [key: string]: unknown };
              contexts?: string | null;
              message?: string | null;
              packages?: string | null;
              tags?: { [key: string]: unknown };
              sdk?: string | null;
            };
            contexts: { [key: string]: unknown };
            fingerprints: string[];
            context: { [key: string]: unknown };
            release:
              | (
                  | {
                      authors: { [key: string]: unknown }[];
                      /** Format: int64 */
                      commitCount: number;
                      data: { [key: string]: unknown };
                      /** Format: date-time */
                      dateCreated: string;
                      /** Format: date-time */
                      dateReleased: string | null;
                      /** Format: int64 */
                      deployCount: number;
                      /** Format: date-time */
                      firstEvent: string | null;
                      lastCommit: { [key: string]: unknown } | null;
                      lastDeploy:
                        | (
                            | {
                                environment: string;
                                name: string | null;
                                /** Format: date-time */
                                dateStarted: string | null;
                                /** Format: date-time */
                                dateFinished: string;
                                url: string | null;
                                id: string;
                              }
                            | (unknown | null)
                          )
                        | null;
                      /** Format: date-time */
                      lastEvent: string | null;
                      /** Format: int64 */
                      newGroups: number;
                      owner: { [key: string]: unknown } | null;
                      projects: {
                        name?: string;
                        slug?: string;
                      }[];
                      ref: string | null;
                      shortVersion: string;
                      version: string;
                      url: string | null;
                    }
                  | (unknown | null)
                )
              | null;
            groupID: string;
            title: string;
          };
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** This endpoint lists an issue's events. */
  "List an Issue's Events": {
    parameters: {
      path: {
        /** The ID of the issue to retrieve. */
        issue_id: string;
      };
      query: {
        /**
         * If this is set to true then the event payload will include the full event body, including the stacktrace.
         * Set to true to enable.
         */
        full?: boolean;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            eventID: string;
            tags: {
              value?: string;
              key?: string;
            }[];
            dateCreated: string;
            user: {
              username: string | null;
              name: string | null;
              ip_address: string | null;
              email: string | null;
              data: {
                isStaff?: boolean;
              } | null;
              id: string;
            } | null;
            message: string;
            id: string;
            platform: string;
            "event.type": string;
            groupID: string;
            title: string;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** Return details on an individual issue. This returns the basic stats for the issue (title, last seen, first seen), some overall numbers (number of comments, user reports) as well as the summarized event data. */
  "Retrieve an Issue": {
    parameters: {
      path: {
        /** The ID of the issue to retrieve. */
        issue_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            activity: {
              data?: { [key: string]: unknown };
              dateCreated?: string;
              id?: string;
              type?: string;
              user?: { [key: string]: unknown } | null;
            }[];
            annotations: string[];
            assignedTo: { [key: string]: unknown } | null;
            count: string;
            culprit: string;
            firstRelease: {
              authors?: string[];
              commitCount?: number;
              data?: { [key: string]: unknown } | null;
              dateCreated?: string;
              dateReleased?: string | null;
              deployCount?: number;
              firstEvent?: string;
              lastCommit?: string | null;
              lastDeploy?: string | null;
              lastEvent?: string;
              newGroups?: number;
              owner?: string | null;
              projects?: {
                name?: string;
                slug?: string;
              }[];
              ref?: string | null;
              shortVersion?: string;
              url?: string | null;
              version?: string;
            } | null;
            firstSeen: string;
            hasSeen: boolean;
            id: string;
            isBookmarked: boolean;
            isPublic: boolean;
            isSubscribed: boolean;
            lastRelease: { [key: string]: unknown } | null;
            lastSeen: string;
            level: string;
            logger: string | null;
            metadata:
              | {
                  filename: string;
                  type: string;
                  value: string;
                }
              | {
                  title: string;
                };
            numComments: number;
            participants: { [key: string]: unknown }[];
            permalink: string;
            pluginActions: string[][];
            pluginContexts: string[];
            pluginIssues: { [key: string]: unknown }[];
            project: {
              id?: string;
              name?: string;
              slug?: string;
            };
            seenBy: { [key: string]: unknown }[];
            shareId: string | null;
            shortId: string;
            stats: {
              "24h"?: number[][];
              "30d"?: number[][];
            };
            /** @enum {string} */
            status: "resolved" | "unresolved" | "ignored";
            statusDetails: { [key: string]: unknown };
            subscriptionDetails: { [key: string]: unknown } | null;
            tags: { [key: string]: unknown }[];
            title: string;
            type: string;
            userCount: number;
            userReportCount: number;
          };
        };
      };
      /** Forbidden */
      403: unknown;
    };
  };
  /** Updates an individual issue's attributes.  Only the attributes submitted are modified. */
  "Update an Issue": {
    parameters: {
      path: {
        /** The ID of the group to retrieve. */
        issue_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            annotations: string[];
            assignedTo: { [key: string]: unknown } | null;
            count: string;
            culprit: string;
            firstSeen: string;
            hasSeen: boolean;
            id: string;
            isBookmarked: boolean;
            isPublic: boolean;
            isSubscribed: boolean;
            lastSeen: string;
            level: string;
            logger: string | null;
            metadata:
              | {
                  filename: string;
                  type: string;
                  value: string;
                }
              | {
                  title: string;
                };
            numComments: number;
            permalink: string;
            project: {
              id?: string;
              name?: string;
              slug?: string;
            };
            shareId: string | null;
            shortId: string;
            /** @enum {string} */
            status: "resolved" | "unresolved" | "ignored";
            statusDetails: { [key: string]: unknown };
            subscriptionDetails: { [key: string]: unknown } | null;
            title: string;
            type: string;
            userCount: number;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The new status for the issues. Valid values are `"resolved"`, `"resolvedInNextRelease"`, `"unresolved"`, and `"ignored"`. */
          status?: string;
          /** @description The actor id (or username) of the user or team that should be assigned to this issue. */
          assignedTo?: string;
          /** @description In case this API call is invoked with a user context this allows changing of the flag that indicates if the user has seen the event. */
          hasSeen?: boolean;
          /** @description In case this API call is invoked with a user context this allows changing of the bookmark flag. */
          isBookmarked?: boolean;
          isSubscribed?: boolean;
          /** @description Sets the issue to public or private. */
          isPublic?: boolean;
        };
      };
    };
  };
  /** Removes an individual issue. */
  "Remove an Issue": {
    parameters: {
      path: {
        /** The ID of the issue to delete. */
        issue_id: string;
      };
    };
    responses: {
      /** Success */
      202: unknown;
      /** Forbidden */
      403: unknown;
      /** The requested resource does not exist */
      404: unknown;
    };
  };
  /** Return a list of releases for a given organization. */
  "List an Organization's Releases": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
      };
      query: {
        /** This parameter can be used to create a "starts with" filter for the version. */
        query?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            authors: { [key: string]: unknown }[];
            /** Format: int64 */
            commitCount: number;
            data: { [key: string]: unknown };
            /** Format: date-time */
            dateCreated: string;
            /** Format: date-time */
            dateReleased: string | null;
            /** Format: int64 */
            deployCount: number;
            /** Format: date-time */
            firstEvent: string | null;
            lastCommit: { [key: string]: unknown } | null;
            lastDeploy:
              | (
                  | {
                      environment: string;
                      name: string | null;
                      /** Format: date-time */
                      dateStarted: string | null;
                      /** Format: date-time */
                      dateFinished: string;
                      url: string | null;
                      id: string;
                    }
                  | (unknown | null)
                )
              | null;
            /** Format: date-time */
            lastEvent: string | null;
            /** Format: int64 */
            newGroups: number;
            owner: { [key: string]: unknown } | null;
            projects: {
              name?: string;
              slug?: string;
            }[];
            ref: string | null;
            shortVersion: string;
            version: string;
            url: string | null;
          }[];
        };
      };
      /** Permission Denied */
      401: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /**
   * Create a new release for the given organization.  Releases are used by
   * Sentry to improve its error reporting abilities by correlating
   * first seen events with the release that might have introduced the
   * problem.
   * Releases are also necessary for source maps and other debug features
   * that require manual upload for functioning well.
   */
  "Create a New Release for an Organization": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            authors: { [key: string]: unknown }[];
            /** Format: int64 */
            commitCount: number;
            data: { [key: string]: unknown };
            /** Format: date-time */
            dateCreated: string;
            /** Format: date-time */
            dateReleased: string | null;
            /** Format: int64 */
            deployCount: number;
            /** Format: date-time */
            firstEvent: string | null;
            lastCommit: { [key: string]: unknown } | null;
            lastDeploy:
              | (
                  | {
                      environment: string;
                      name: string | null;
                      /** Format: date-time */
                      dateStarted: string | null;
                      /** Format: date-time */
                      dateFinished: string;
                      url: string | null;
                      id: string;
                    }
                  | (unknown | null)
                )
              | null;
            /** Format: date-time */
            lastEvent: string | null;
            /** Format: int64 */
            newGroups: number;
            owner: { [key: string]: unknown } | null;
            projects: {
              name?: string;
              slug?: string;
            }[];
            ref: string | null;
            shortVersion: string;
            version: string;
            url: string | null;
          };
        };
      };
      /** Bad Input */
      400: unknown;
      /** Forbidden */
      403: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A version identifier for this release. Can be a version number, a commit hash, etc. */
          version: string;
          /** @description An optional commit reference. This is useful if a tagged version has been provided. */
          ref?: string;
          /** @description A URL that points to the release. This can be the path to an online interface to the source code for instance */
          url?: string;
          /** @description A list of project slugs that are involved in this release. */
          projects: string[];
          /**
           * Format: date-time
           * @description An optional date that indicates when the release went live. If not provided the current time is assumed.
           */
          dateReleased?: string;
          /** @description An optional list of commit data to be associated with the release. Commits must include parameters `id` (the SHA of the commit), and can optionally include `repository`, `message`, `patch_set`, `author_name`, `author_email`, and `timestamp`. */
          commits?: {
            /** @description A list of the files that have been changed in the commit. Specifying the patch_set is necessary to power suspect commits and suggested assignees. */
            patch_set?: {
              /** @description The path to the file. Both forward and backward slashes are supported. */
              path: string;
              /**
               * @description The type of change that happened in the commit.
               * @enum {string}
               */
              type: "A" | "M" | "D";
            }[];
            /** @description The full name of the repository the commit belongs to. If this field is not given Sentry will generate a name in the form: u'organization-<organization_id>' (i.e. if the organization id is 123, then the generated repository name will be u'organization-123). */
            repository?: string;
            /** @description The name of the commit author. */
            author_name?: string;
            /** @description The email of the commit author. The commit author's email is required to enable the suggested assignee feature. */
            author_email?: string;
            /**
             * Format: date-time
             * @description The commit timestamp is used to sort the commits given. If a timestamp is not included, the commits will remain sorted in the order given.
             */
            timestamp?: string;
            /** @description The commit message. */
            message?: string;
            /** @description The commit ID (the commit SHA). */
            id?: string;
          }[];
          /** @description An optional way to indicate the start and end commits for each repository included in a release. Head commits must include parameters `repository` and `commit` (the HEAD sha). They can optionally include `previousCommit` (the sha of the HEAD of the previous release), which should be specified if this is the first time you've sent commit data. `commit` may contain a range in the form of `previousCommit..commit`. */
          refs?: {
            /** @description The full name of the repository the commit belongs to. */
            repository?: string;
            /** @description The current release's commit. */
            commit?: string;
            /** @description The previous release's commit. */
            previousCommit?: string;
          }[];
        };
      };
    };
  };
  /** Return a release for a given organization. */
  "Retrieve an Organization's Releases": {
    parameters: {
      path: {
        /** The slug of the organization the release belongs to. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            authors: { [key: string]: unknown }[];
            /** Format: int64 */
            commitCount: number;
            data: { [key: string]: unknown };
            /** Format: date-time */
            dateCreated: string;
            /** Format: date-time */
            dateReleased: string | null;
            /** Format: int64 */
            deployCount: number;
            /** Format: date-time */
            firstEvent: string | null;
            lastCommit: { [key: string]: unknown } | null;
            lastDeploy:
              | (
                  | {
                      environment: string;
                      name: string | null;
                      /** Format: date-time */
                      dateStarted: string | null;
                      /** Format: date-time */
                      dateFinished: string;
                      url: string | null;
                      id: string;
                    }
                  | (unknown | null)
                )
              | null;
            /** Format: date-time */
            lastEvent: string | null;
            /** Format: int64 */
            newGroups: number;
            owner: { [key: string]: unknown } | null;
            projects: {
              name?: string;
              slug?: string;
            }[];
            ref: string | null;
            shortVersion: string;
            version: string;
            url: string | null;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Update a release for a given organization. */
  "Update an Organization's Release": {
    parameters: {
      path: {
        /** The slug of the organization the release belongs to. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            authors: { [key: string]: unknown }[];
            /** Format: int64 */
            commitCount: number;
            data: { [key: string]: unknown };
            /** Format: date-time */
            dateCreated: string;
            /** Format: date-time */
            dateReleased: string | null;
            /** Format: int64 */
            deployCount: number;
            /** Format: date-time */
            firstEvent: string | null;
            lastCommit: { [key: string]: unknown } | null;
            lastDeploy:
              | (
                  | {
                      environment: string;
                      name: string | null;
                      /** Format: date-time */
                      dateStarted: string | null;
                      /** Format: date-time */
                      dateFinished: string;
                      url: string | null;
                      id: string;
                    }
                  | (unknown | null)
                )
              | null;
            /** Format: date-time */
            lastEvent: string | null;
            /** Format: int64 */
            newGroups: number;
            owner: { [key: string]: unknown } | null;
            projects: {
              name?: string;
              slug?: string;
            }[];
            ref: string | null;
            shortVersion: string;
            version: string;
            url: string | null;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional commit reference. This is useful if a tagged version has been provided. */
          ref?: string;
          /** @description A URL that points to the release. This can be the path to an online interface to the source code for instance. */
          url?: string;
          /**
           * Format: date-time
           * @description An optional date that indicates when the release went live. If not provided the current time is assumed.
           */
          dateReleased?: string;
          /** @description An optional list of commit data to be associated with the release. Commits must include parameters `id` (the sha of the commit), and can optionally include `repository`, `message`, `author_name`, `author_email`, and `timestamp`. */
          commits?: { [key: string]: unknown }[];
          /** @description An optional way to indicate the start and end commits for each repository included in a release. Head commits must include parameters `repository` and `commit` (the HEAD sha). They can optionally include `previousCommit` (the sha of the HEAD of the previous release), which should be specified if this is the first time you've sent commit data. */
          refs?: { [key: string]: unknown }[];
        };
      };
    };
  };
  /** Delete a release for a given organization. */
  "Delete an Organization's Release": {
    parameters: {
      path: {
        /** The slug of the organization the release belongs to. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      204: never;
    };
  };
  /** Return a list of files for a given release. */
  "List an Organization's Release Files": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            sha1: string;
            dist: string | null;
            name: string;
            /** Format: date-time */
            dateCreated: string;
            headers: { [key: string]: unknown };
            id: string;
            size: number;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Upload a new organization release file. */
  "Upload a New Organization Release File": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      201: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** @description The name (full path) of the file. */
          name?: string;
          /**
           * Format: binary
           * @description The multipart encoded file.
           */
          file: string;
          /** @description The name of the dist. */
          dist?: string;
          /** @description This parameter can be supplied multiple times to attach headers to the file. Each header is a string in the format `key:value`. For instance it can be used to define a content type. */
          header?: string;
        };
      };
    };
  };
  /** Return a list of files for a given release. */
  "List a Project's Release Files": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            sha1: string;
            dist: string | null;
            name: string;
            /** Format: date-time */
            dateCreated: string;
            headers: { [key: string]: unknown };
            id: string;
            size: number;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Upload a new project release file. */
  "Upload a New Project Release File": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            sha1: string;
            dist: string | null;
            name: string;
            /** Format: date-time */
            dateCreated: string;
            headers: { [key: string]: unknown };
            id: string;
            size: number;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** @description The name (full path) of the file. */
          name?: string;
          /**
           * Format: binary
           * @description The multipart encoded file.
           */
          file: string;
          /** @description The name of the dist. */
          dist?: string;
          /** @description This parameter can be supplied multiple times to attach headers to the file. Each header is a string in the format `key:value`. For instance it can be used to define a content type. */
          header?: string;
        };
      };
    };
  };
  /** Retrieve a file for a given release. */
  "Retrieve an Organization Release's File": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
        /** The ID of the file to retrieve. */
        file_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            sha1: string;
            dist: string | null;
            name: string;
            /** Format: date-time */
            dateCreated: string;
            headers: { [key: string]: unknown };
            id: string;
            size: number;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Update an organization release file. */
  "Update an Organization Release File": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
        /** The ID of the file to retrieve. */
        file_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            sha1: string;
            dist: string | null;
            name: string;
            /** Format: date-time */
            dateCreated: string;
            headers: { [key: string]: unknown };
            id: string;
            size: number;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The new name (full path) of the file. */
          name?: string;
          /** @description The new name of the dist. */
          dist?: string;
        };
      };
    };
  };
  /** Delete a file for a given release. */
  "Delete an Organization Release's File": {
    parameters: {
      path: {
        /** The slug of the organization the release belongs to. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
        /** The ID of the file to delete. */
        file_id: string;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Retrieve a file for a given release. */
  "Retrieve a Project Release's File": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
        /** The version identifier of the release. */
        version: string;
        /** The ID of the file to retrieve. */
        file_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            sha1: string;
            dist: string | null;
            name: string;
            /** Format: date-time */
            dateCreated: string;
            headers: { [key: string]: unknown };
            id: string;
            size: number;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Update a project release file. */
  "Update a Project Release File": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
        /** The version identifier of the release. */
        version: string;
        /** The ID of the file to retrieve. */
        file_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            sha1: string;
            dist: string | null;
            name: string;
            /** Format: date-time */
            dateCreated: string;
            headers: { [key: string]: unknown };
            id: string;
            size: number;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The new name (full path) of the file. */
          name?: string;
          /** @description The new name of the dist. */
          dist?: string;
        };
      };
    };
  };
  /** Delete a file for a given release. */
  "Delete a Project Release's File": {
    parameters: {
      path: {
        /** The slug of the organization the release belongs to. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
        /** The version identifier of the release. */
        version: string;
        /** The ID of the file to delete. */
        file_id: string;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** List an organization release's commits. */
  "List an Organization Release's Commits": {
    parameters: {
      path: {
        /** The slug of the organization the release belongs to. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** Format: date-time */
            dateCreated: string;
            id: string;
            message: string | null;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** List a project release's commits. */
  "List a Project Release's Commits": {
    parameters: {
      path: {
        /** The slug of the organization the release belongs to. */
        organization_slug: string;
        /** The slug of the project the release belongs to. */
        project_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** Format: date-time */
            dateCreated: string;
            id: string;
            message: string | null;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Retrieve files changed in a release's commits */
  "Retrieve Files Changed in a Release's Commits": {
    parameters: {
      path: {
        /** The slug of the organization the release belongs to. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      200: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** List issues to be resolved in a particular release. */
  "List Issues to be Resolved in a Particular Release": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The slug of the project. */
        project_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      200: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Return a list of deploys for a given release. */
  "List a Release's Deploys": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            environment: string;
            name: string | null;
            /** Format: date-time */
            dateStarted: string | null;
            /** Format: date-time */
            dateFinished: string;
            url: string | null;
            id: string;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Create a deploy. */
  "Create a New Deploy for an Organization": {
    parameters: {
      path: {
        /** The slug of the organization. */
        organization_slug: string;
        /** The version identifier of the release. */
        version: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            environment: string;
            name: string | null;
            /** Format: date-time */
            dateStarted: string | null;
            /** Format: date-time */
            dateFinished: string;
            url: string | null;
            id: string;
          };
        };
      };
      /** Already Reported */
      208: unknown;
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The environment you're deploying to. */
          environment: string;
          /** @description The optional URL that points to the deploy. */
          url?: string;
          /** @description The optional name of the deploy. */
          name?: string;
          /** @description The optional list of projects to deploy. */
          projects?: unknown[];
          /**
           * Format: date-time
           * @description An optional date that indicates when the deploy started.
           */
          dateStarted?: string;
          /**
           * Format: date-time
           * @description An optional date that indicates when the deploy ended. If not provided, the current time is used.
           */
          dateFinished?: string;
        };
      };
    };
  };
  /** Return a list of integration platform installations for a given organization. */
  "List an Organization's Integration Platform Installations": {
    parameters: {
      path: {
        /** The organization short name. */
        organization_slug: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            app: {
              uuid: string;
              slug: string;
            };
            organization: {
              slug: string;
            };
            uuid: string;
            status: string;
          }[];
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
  };
  /** Create an external issue from an integration platform integration. */
  "Create an External Issue": {
    parameters: {
      path: {
        /** The uuid of the integration platform integration. */
        uuid: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            id: string;
            issueId: string;
            serviceType: string;
            displayName: string;
            webUrl: string;
          };
        };
      };
      /** Forbidden */
      403: unknown;
      /** Not Found */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of the Sentry issue to link the external issue to. */
          issueId: number;
          /** @description The URL of the external service to link the issue to. */
          webUrl: string;
          /** @description The external service's project. */
          project: string;
          /** @description A unique identifier of the external issue. */
          identifier: string;
        };
      };
    };
  };
  /** Delete an external issue. */
  "Delete an External Issue": {
    parameters: {
      path: {
        /** The uuid of the integration platform integration. */
        uuid: string;
        /** The id of the external issue. */
        external_issue_id: string;
      };
    };
    responses: {
      /** Success */
      204: never;
      /** Forbidden */
      403: unknown;
      /** External issue not found */
      404: unknown;
    };
  };
}

export interface external {}
